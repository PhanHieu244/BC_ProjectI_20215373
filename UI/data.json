{
    "Tuần 1": {
        "Bai1": {
            "Code":"#include <iostream>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int n;\n    cin >> n; // Read the value of n\n\n    int sum_53 = 0;\n    int num_53;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> num_53; // Read each element of the sequence\n        sum_53 += num_53; // Add the element to the sum\n    }\n\n    cout << sum_53 << endl; // Print the sum\n\n    return 0;\n}\n",
            "Problem": "Problem: Week 1 - Sum Array\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. Compute the sum Q of elements of this sequence.\n\nInput\nLine 1: contains n (1 <= n <= 1000000)\nLine 2: contains a1, a2, ..., an (-10000 <= ai <= 10000)\n\nOutput\nWrite the value of Q\n\nExample\n\nInput\n4\n3 2 5 4\n\nOutput\n14"
        },
        "Bai2": {
            "Problem": "Problem: Week 1 - List sequence of integer having 3 digits divisible by n\n\nDescription\nGiven a positive integer n, find all integer having 3 digits which is divisible by n.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 999)\n\nOutput\nWrite the sequence of numbers found (elements are separated by a SPACE character)\n\nExample\nInput \n200\n\nOutput \n200 400 600 800",
            "Code": "#include <iostream>\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int n_53;\n    cin >> n_53; // Read the input value\n\n    // Initialize a flag to check if any numbers were found\n    bool found_53 = false;\n\n    // Loop through three-digit numbers and check if they are divisible by n\n    for (int num = 100; num < 1000; num++) {\n        if (num % n_53 == 0) {\n            if (found_53) {\n                cout << \" \"; // Print a space if this is not the first number\n            }\n            cout << num; // Print the divisible number\n            found_53 = true; // Set the found flag to true\n        }\n    }\n\n    cout << endl; // Print a newline character at the end\n\n    return 0;\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 1 - So s\u00e1nh ch\u00eanh l\u1ec7ch gi\u00e1 \u0111i\u1ec7n theo \u0111\u1ec1 xu\u1ea5t m\u1edbi c\u1ee7a EVN\n\nDescription\nHi\u1ec7n t\u1ea1i gi\u00e1 \u0111i\u1ec7n \u0111ang \u0111\u01b0\u1ee3c t\u00ednh theo b\u1eadc thang g\u1ed3m 6 m\u1ee9c (m\u1ee9c \u0111i\u1ec1u ch\u1ec9nh t\u1eeb 04/05/2023), v\u1edbi gi\u00e1 th\u1ea5p nh\u1ea5t (b\u1eadc 1) l\u00e0 1.728VND v\u00e0 gi\u00e1 b\u1eadc cao nh\u1ea5t l\u00e0 3.015 VND. Tuy nhi\u00ean EVN \u0111ang \u0111\u1ec1 xu\u1ea5t m\u1ed9t c\u00e1ch t\u00ednh gi\u00e1 \u0111i\u1ec7n b\u1eadc thang m\u1edbi ch\u1ec9 g\u1ed3m 5 m\u1ee9c nh\u01b0 hinh d\u01b0\u1edbi, gi\u00e1 th\u1ea5p nh\u1ea5t (b\u1eadc 1) kho\u1ea3ng 1.728 \u0111\u1ed3ng m\u1ed9t kWh v\u00e0 cao nh\u1ea5t (b\u1eadc 5) l\u00e0 3.457 \u0111\u1ed3ng m\u1ed9t kWh. \n\nB\u1eadc\tBi\u1ec3u gi\u00e1 hi\u1ec7n h\u00e0nh\tPh\u01b0\u01a1ng \u00e1n 5 b\u1eadc\n  \tM\u1ee9c s\u1eed d\u1ee5ng\tGi\u00e1 (*)\tM\u1ee9c s\u1eed d\u1ee5ng\tGi\u00e1\n1\t0-50 kWh\t1.728\t0-100 kWh\t1.728\n2\t51-100 kWh\t1.786\t101-200 kWh\t2.074\n3\t101-200 kWh\t2.074\t201-400 kWh\t2.612\n4\t201-300 kWh\t2.612\t401-700 kWh\t3.111\n5\t301-400 kWh\t2.919\t701 kWh tr\u1edf l\u00ean\t3.457\n6  \t401 kWh tr\u1edf l\u00ean\t3.015\t\t\n(*) Gi\u00e1 ch\u01b0a bao g\u1ed3m thu\u1ebf VAT\n\nH\u00e3y x\u00e2y d\u1ef1ng ch\u01b0\u01a1ng tr\u00ecnh nh\u1eadp v\u00e0o s\u1ed1 kwh \u0111i\u1ec7n c\u1ee7a m\u1ed9t h\u1ed9 ti\u00eau th\u1ee5 v\u00e0 so s\u00e1nh xem theo b\u1ea3ng gi\u00e1 m\u1edbi \u0111ang l\u1ea5y \u00fd ki\u1ebfn th\u00ec ti\u1ec1n \u0111i\u1ec7n ti\u00eau th\u1ee5 c\u1ee7a h\u1ed9 \u0111\u00f3 s\u1ebd t\u0103ng th\u00eam hay gi\u1ea3m \u0111i bao nhi\u00eau.\n\nINPUT: l\u00e0 s\u1ed1 kwh \u0111i\u1ec7n ti\u00eau th\u1ee5 c\u1ee7a h\u1ed9 (l\u00e0 s\u1ed1 nguy\u00ean)\nOUTPUT: l\u00e0 ch\u00eanh l\u1ec7ch gi\u1eefa gi\u00e1 theo \u0111\u1ec1 xu\u1ea5t v\u00e0 gi\u00e1 theo m\u00f4 h\u00ecnh b\u1eadc thang 6 m\u1ee9c \u0111ang \u0111\u01b0\u1ee3c \u00e1p d\u1ee5ng.\n\nVAT s\u1ebd \u0111\u01b0\u1ee3c l\u1ea5y l\u00e0 10%, v\u00e0 k\u1ebft qu\u1ea3 in ra s\u1ebd l\u1ea5y t\u1edbi 2 ch\u1eef s\u1ed1 th\u1eadp ph\u00e2n\n\nEXAMPLE \nINPUT\n540\nOUTPUT\n-22176.00\n\n\nINPUT\n70\nOUTPUT\n-1276.00",
            "Code": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int consumedKWh_53;\n    cin >> consumedKWh_53; // Đọc số kWh điện tiêu thụ của hộ\n\n    double proposedPrice_53; // Giá điện theo đề xuất\n    double currentPrice_53;  // Giá điện theo mô hình bậc thang 6 mức\n\n    // Tính giá điện theo đề xuất (5 mức)\n    if (consumedKWh_53 <= 100) {\n        proposedPrice_53 = consumedKWh_53 * 1.728;\n    } else if (consumedKWh_53 <= 200) {\n        proposedPrice_53 = 100 * 1.728 + (consumedKWh_53 - 100) * 2.074;\n    } else if (consumedKWh_53 <= 400) {\n        proposedPrice_53 = 100 * 1.728 + 100 * 2.074 + (consumedKWh_53 - 200) * 2.612;\n    } else if (consumedKWh_53 <= 700) {\n        proposedPrice_53 = 100 * 1.728 + 100 * 2.074 + 200 * 2.612 + (consumedKWh_53 - 400) * 3.111;\n    } else {\n        proposedPrice_53 = 100 * 1.728 + 100 * 2.074 + 200 * 2.612 + 300 * 3.111 + (consumedKWh_53 - 700) * 3.457;\n    }\n\n    // Tính giá điện theo mô hình bậc thang 6 mức\n    if (consumedKWh_53 <= 50) {\n        currentPrice_53 = consumedKWh_53 * 1.728;\n    } else if (consumedKWh_53 <= 100) {\n        currentPrice_53 = 50 * 1.728 + (consumedKWh_53 - 50) * 1.786;\n    } else if (consumedKWh_53 <= 200) {\n        currentPrice_53 = 50 * 1.728 + 50 * 1.786 + (consumedKWh_53 - 100) * 2.074;\n    } else if (consumedKWh_53 <= 300) {\n        currentPrice_53 = 50 * 1.728 + 50 * 1.786 + 100 * 2.074 + (consumedKWh_53 - 200) * 2.612;\n    } else if (consumedKWh_53 <= 400) {\n        currentPrice_53 = 50 * 1.728 + 50 * 1.786 + 100 * 2.074 + 100 * 2.612 + (consumedKWh_53 - 300) * 2.919;\n    } else {\n        currentPrice_53 = 50 * 1.728 + 50 * 1.786 + 100 * 2.074 + 100 * 2.612 + 100 * 2.919 + (consumedKWh_53 - 400) * 3.015;\n    }\n\n    // Tính chênh lệch giữa giá theo đề xuất và giá theo mô hình bậc thang 6 mức\n    double priceDifference_53 = proposedPrice_53 - currentPrice_53;\n\n    // Áp dụng thuế VAT 10%\n    priceDifference_53 *= 1100;\n\n    // In kết quả với 2 chữ số thập phân\n    cout << fixed << setprecision(2) << priceDifference_53 << endl;\n\n    return 0;\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 1 - Convert a TEXT to Upper-Case\n\nDescription\nGiven a TEXT, write a program that converts the TEXT to upper-case. \n\nInput\nThe TEXT\n\nOutput\nThe TEXT in which characters are converted into upper-case\n\nExample \nInput \nHello John,\nHow are you?\n\nBye,\n\nOutput \nHELLO JOHN,\nHOW ARE YOU?\n\nBYE, ",
            "Code": "#include <iostream>\n#include <string>\n#include <cctype> // For the toupper function\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    string text_53;\n\n    // Read the input text\n    while (getline(cin, text_53)) {\n        // Convert the text to uppercase\n        for (size_t i = 0; i < text_53.length(); ++i) {\n            text_53[i] = toupper(text_53[i]);\n        }\n\n        // Print the converted text\n        cout << text_53 << endl;\n    }\n\n    return 0;\n}\n"
        },
        "Bai5": {
            "Problem": "Problem: Week 1 - Extract Year, Month, Date from a String YYYY-MM-DD\n\nDescription\nGiven a date which is a string under the format YYYY-MM-DD (in which YYYY is the year, MM is the month (the month \u00ed from 1 to 12), and DD is the date (the date is from 1 to 31)). Extract the year, month and date.\n\nInput\nLine 1: contains a string s  \nOutput\nif s is not under the format YYYY-MM-DD, then write INCORRECT. Otherwise, write year, month, and date separated by a SPACE character\n\nExample\nInput\n2023-10-04\nOutput\n2023 10 4\n\n\nInput\n2023-10-4\nOutput\nINCORRECT \n\nInput\n2023-10 04\nOutput\nINCORRECT\n",
            "Code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    //Phan Trung Hieu 20215373\n    string s_53;\n    getline(cin, s_53);\n    \n    // Check if the input string is not of the form \"YYYY-MM-DD\" or is not of length 10\n    if (s_53.size() != 10 || s_53[4] != '-' || s_53[7] != '-')\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    // Extract the month and day from the input string\n    int month_53 = (s_53[5] - 48) * 10 + (s_53[6] - 48);\n    int day_53 = (s_53[8] - 48) * 10 + (s_53[9] - 48);\n\n    // Check if the month and day are valid\n    if (month_53 < 1 || month_53 > 12 || day_53 < 1 || day_53 > 31)\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    // Print the date in a different format\n    for (int i = 0; i < 10; i++)\n    {\n        if (s_53[i] == '-')\n            cout << ' ';\n        else if (i > 4 && s_53[i] == '0')\n            continue;\n        else\n            cout << s_53[i];\n    }\n}\n"
        },
        "Bai6": {
            "Problem": "Problem: Week 1 - List all numbers from 1 to n and its squares\n\nDescription\nGiven an integer n, print numbers from 1 to n and its squares.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 100)\nOutput\nEach line i (i = 1,...,n): contains i and i^2 (elements are separated by one SPACE character)\n\nExample\nInput\n3\nOutput\n1 1\n2 4\n3 9",
            "Code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int n_53;\n    cin >> n_53; // Read the value of n\n\n    for (int i = 1; i <= n_53; ++i) {\n        int square_53 = i * i;\n        cout << i << \" \" << square_53 << endl;\n    }\n\n    return 0;\n}\n"
        },
        "Bai7": {
            "Problem": "Problem: Week 1 - Count odd and even number from a sequence\n\nDescription\nGiven a sequence of integer a1, a2, ..., an. Count the number of odd elements and even elements of the sequence.\n\nInput\nLine 1: contains a positive integer n (1 <= n <= 100000)\nLine 2: contains a1, a2, ..., an. (1 <= ai <= 1000000)\nOutput\nWrite the number of odd elements and the number of even elements (separated by a SPACE character)\n\nExample \nInput \n6\n2 3 4 3 7 1\nOutput \n4 2",
            "Code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int n;\n    cin >> n; // Read the value of n\n\n    int oddCount_53 = 0;\n    int evenCount_53 = 0;\n    int num_53;\n\n    for (int i = 0; i < n; ++i) {\n        cin >> num_53; // Read each element of the sequence\n\n        if (num_53 % 2 == 0) {\n            evenCount_53++; // Increment even count if the element is even\n        } else {\n            oddCount_53++; // Increment odd count if the element is odd\n        }\n    }\n\n    cout << oddCount_53 << \" \" << evenCount_53 << endl; // Print the counts\n\n    return 0;\n}\n"
        },
        "Bai8": {
            "Problem": "Problem: Week 1 - Add Subtract Multiplication Division of A and B\n\nDescription\nGiven 2 integers a and b. Compute a+b, a-b, a*b, a/b.\n\nInput\nLine 1 contains 2 integers a and b (1 <= a,b <= 1000)\nOutput\nWrite a+b, a-b, a*b, a/b  (4 integers are separated by a SPACE characters)\n\nExample\nInput\n9 4\n\nOutput \n13 5 36 2",
            "Code": "#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int a, b;\n    cin >> a >> b; // Read the values of a and b\n\n    int sum_53 = a + b;\n    int diff_53 = a - b;\n    int product_53 = a * b;\n\n    // Check if b is not zero to avoid division by zero\n    int division_53 = (b != 0) ? a / b : 0.0;\n\n    // Print the results\n    cout << sum_53 << \" \" << diff_53 << \" \" << product_53 << \" \" << fixed << setprecision(2) << division_53 << endl;\n\n    return 0;\n}\n"
        },
        "Bai9": {
            "Problem": "Problem: Week 1 - Convert hh:mm:ss to seconds\n\nDescription\nGiven a time moment which is a string under the format hh:mm:ss (in which hh (0 <= hh <= 23) is the hour, mm (0 <= mm <= 59) is the minute, and ss (0 <= ss <= 59) is the second). Convert this time moment in seconds (result = hh*3600 + mm*60 + ss).\n\nInput\nLine 1: contains a string s representing the time moment.  \nOutput\nif s is not under the format hh:mm:ss, then write INCORRECT. Otherwise, write value converted.\n\nExample\nInput\n13:05:26\n\nOutput\n47126\n\n\nInput\n13:05:6\n\nOutput\nINCORRECT \n\nInput\n13:05 26\n\nOutput\nINCORRECT",
            "Code":"#include <iostream>\nusing namespace std;\n\nint main()\n{\n    //Phan Trung Hieu 20215373\n    // Read a string from the standard input\n    string s;\n    getline(cin, s);\n\n    // Check if the input string is not of the form \"HH:MM:SS\" or is not of length 8\n    if (s.size() != 8 || s[2] != ':' || s[5] != ':')\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    // Extract the hour, minute, and second from the input string\n    int hour_53 = (s[0] - 48) * 10 + (s[1] - 48);\n    int minute_53 = (s[3] - 48) * 10 + (s[4] - 48);\n    int second_53 = (s[6] - 48) * 10 + (s[7] - 48);\n\n    // Check if the hour, minute, and second are within valid ranges\n    if (hour_53 < 0 || hour_53 > 23 || minute_53 < 0 || minute_53 > 59 || second_53 < 0 || second_53 > 59)\n    {\n        cout << \"INCORRECT\";\n        return 0;\n    }\n\n    // Calculate the total number of seconds and print it\n    cout << hour_53 * 3600 + minute_53 * 60 + second_53;\n}\n"
        },
        "Bai10": {
            "Problem": "Problem: Week 1 - Solve degree-2 polynomial equation\n\nDescription\nGiven an equation ax^2 + bx + c = 0. Find solution to the given equation.\n\nInput\nLine 1 contains 3 integers a, b, c \nOutput\nWrite NO SOLUTION if the given equation has no solution \nWrite x0 (2 digits after the decimal point) if the given equation has one solution x0 \nWrite x1 and x2 with x1 < x2 (2 digits after the decimal point) if the given equation has two distinct solutions x1, x2 \n\nExample\nInput \n1 1 8\nOutput \nNO SOLUTION \n\n\nInput \n1 -2 1\nOutput\n1.00\n\nInput \n1 -7 10\nOutput \n2.00 5.00",
            "Code": "#include <iostream>\n#include <cmath>\n#include <iomanip> // For setting output precision\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int a_53, b_53, c_53;\n    cin >> a_53 >> b_53 >> c_53; // Read the coefficients a, b, and c\n\n    double discriminant_53 = b_53 * b_53 - 4 * a_53 * c_53; // Calculate the discriminant\n\n    if (a_53 == 0) {\n        // This is not a quadratic equation\n        if (b_53 == 0) {\n            // It's not even a linear equation\n            if (c_53 == 0) {\n                // It's a constant equation (0 = 0)\n                cout << \"INFINITE SOLUTIONS\" << endl;\n            } else {\n                // It's a constant equation (c = 0)\n                cout << \"NO SOLUTION\" << endl;\n            }\n        } else {\n            // It's a linear equation (bx + c = 0)\n            double x = -static_cast<double>(c_53) / b_53;\n            cout << fixed << setprecision(2) << x << endl;\n        }\n    } else if (discriminant_53 > 0) {\n        // Two real and distinct solutions\n        double x1 = (-b_53 - sqrt(discriminant_53)) / (2 * a_53);\n        double x2 = (-b_53 + sqrt(discriminant_53)) / (2 * a_53);\n        cout << fixed << setprecision(2) << x1 << \" \" << x2 << endl;\n    } else if (discriminant_53 == 0) {\n        // One real solution (repeated root)\n        double x0 = -static_cast<double>(b_53) / (2 * a_53);\n        cout << fixed << setprecision(2) << x0 << endl;\n    } else {\n        // No real solutions (complex roots)\n        cout << \"NO SOLUTION\" << endl;\n    }\n\n    return 0;\n}"
        },
        "Bai11": {
            "Problem": "Problem: Week 1 - Basic queries on array\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. Perform a sequence of queries over this sequence including:\nfind-max: return the maximum element of the given sequence\nfind-min: return the minimum element of the given sequence \nsum: return the sum of the elements of the given sequence \nfind-max-segment i j: return the maximum element of the subsequence from index i to index j (i <= j)\n\nInput\nThe first block contains the information about the given sequence with the following format:\nLine 1: contains a positive integer n (1 <= n <= 10000)\nLine 2: contains n integers a1, a2, ..., an (-1000 <= ai <= 1000)\nThe first block is terminated by a character *\nThe second block contains a sequence of queries defined above, each query is in a line. The second block is terminated a 3 characters ***\n\nOutput\nWrite the result of each query in a corresponding line\n \nExample\nInput\n5\n1 4 3 2 5\n*\nfind-max\nfind-min\nfind-max-segment 1 3\nfind-max-segment 2 5\nsum\n***\n\nOutput\n5\n1\n4\n5\n15",
            "Code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int n;\n    cin >> n; // Read the number of elements in the sequence\n\n    vector<int> sequence_53(n);\n\n    // Read the elements of the sequence\n    for (int i = 0; i < n; ++i) {\n        cin >> sequence_53[i];\n    }\n\n    // Process queries\n    string query;\n    while (true) {\n        cin >> query;\n\n        if (query == \"***\") {\n            // Terminate when encountering \"***\"\n            break;\n        }\n\n        if (query == \"find-max\") {\n            // Find and print the maximum element in the sequence\n            int max_element_seq = *max_element(sequence_53.begin(), sequence_53.end());\n            cout << max_element_seq << endl;\n        } else if (query == \"find-min\") {\n            // Find and print the minimum element in the sequence\n            int min_element_seq = *min_element(sequence_53.begin(), sequence_53.end());\n            cout << min_element_seq << endl;\n        } else if (query == \"sum\") {\n            // Calculate and print the sum of the elements in the sequence\n            int sum = 0;\n            for (int i = 0; i < n; ++i) {\n                sum += sequence_53[i];\n            }\n            cout << sum << endl;\n        } else if (query == \"find-max-segment\") {\n            // Find and print the maximum element in a subsequence\n            int i, j;\n            cin >> i >> j;\n            if (i < 1 || i > j || j > n) {\n                cout << \"Invalid query\" << endl;\n            } else {\n                int max_element_segment_53 = *max_element(sequence_53.begin() + i - 1, sequence_53.begin() + j);\n                cout << max_element_segment_53 << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
        },
        "Bai12": {
            "Problem": "Problem: Week 1 - k-Subsequence even\n\nDescription\nGiven a sequence of integers a1, a2, . . ., an. A k-subsequence is define to be a sequence of k consecutive elements: ai, ai+1, . . ., ai+k-1. The weight of a k-subsequence is the sum of its elements.\nGiven positive integers k and m. Compute the number Q of k-subsequences such that the weight is even.\n\nInput\nLine 1: contains 2 positive integers n, k (1 <= n <= 100000, 1 <= k <= n/2)\nLine 2: contains a1, a2, . . ., an. (1 <= ai <= 10000)\nOutput\nWrite the value Q\n\nExample\nInput\n6  3\n2 4 5 1 1 2 \n\nOutput\n2",
            "Code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int n, k;\n    cin >> n >> k; // Read n and k\n\n    vector<int> sequence_53(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> sequence_53[i]; // Read the elements of the sequence\n    }\n\n    int evenCount_53 = 0; // Initialize the count of even-weight k-subsequences\n    int oddCount_53 = 0;  // Initialize the count of odd-weight k-subsequences\n\n    // Calculate the sum of the first k elements as a starting point\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        sum += sequence_53[i];\n    }\n\n    // Check if the sum of the initial k-subsequence is even and update the counts\n    if (sum % 2 == 0) {\n        evenCount_53++;\n    } else {\n        oddCount_53++;\n    }\n\n    // Iterate through the rest of the sequence\n    for (int i = k; i < n; ++i) {\n        sum += sequence_53[i] - sequence_53[i - k]; // Update the sum by adding the next element and subtracting the first element in the k-subsequence\n\n        // Check if the sum of the current k-subsequence is even and update the counts\n        if (sum % 2 == 0) {\n            evenCount_53++;\n        } else {\n            oddCount_53++;\n        }\n    }\n\n    cout << evenCount_53 << endl; // Print the count of even-weight k-subsequences\n\n    return 0;\n}\n"
        },
        "Bai13": {
            "Problem": "Problem: Week 1 - Count words\n\nDescription\nGiven a Text, write a prorgam to count the number Q of words (ignore characters SPACE, TAB, LineBreak) of this Text\n\nInput\nThe Text\n\nOutput\nWrite the number Q of words\n\nExample\nInput\nHanoi University Of Science and Technology\nSchool of Information and Communication Technology\n\n\nOutput\n12",
            "Code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    string line_53;\n    int wordCount_53 = 0;\n\n    // Read lines of text until EOF (End of File)\n    while (getline(cin, line_53)) {\n        stringstream ss(line_53);\n        string word_53;\n\n        // Iterate through the stringstream and count words on each line\n        while (ss >> word_53) {\n            wordCount_53++;\n        }\n    }\n\n    cout << wordCount_53 << endl; // Print the total number of words\n\n    return 0;\n}\n"
        },
            "Bai14": {
            "Problem": "Problem: Week 1 - Text Replacement\n\nDescription\nCho v\u0103n b\u1ea3n T v\u00e0 2 m\u1eabu P1, P2 \u0111\u1ec1u l\u00e0 c\u00e1c x\u00e2u k\u00fd t\u1ef1 (kh\u00f4ng ch\u1ee9a k\u00fd t\u1ef1 xu\u1ed1ng d\u00f2ng, \u0111\u1ed9 d\u00e0i kh\u00f4ng v\u01b0\u1ee3t qu\u00e1 1000). H\u00e3y thay th\u1ebf c\u00e1c x\u00e2u P1 trong T b\u1eb1ng x\u00e2u P2.\n\nD\u1eef li\u1ec7u\n\u00b7 D\u00f2ng 1: x\u00e2u P1\n\u00b7 D\u00f2ng 2: x\u00e2u P2\n\u00b7 D\u00f2ng 3: v\u0103n b\u1ea3n T\nK\u1ebft qu\u1ea3:\n\u00b7 Ghi v\u0103n b\u1ea3n T sau khi thay th\u1ebf\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\nAI\nArtificial Intelligence\nRecently, AI is a key technology. AI enable efficient operations in many fields.\n\nK\u1ebft qu\u1ea3\nRecently, Artificial Intelligence is a key technology. Artificial Intelligence enable efficient operations in many fields.\n",
            "Code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    string P1_53, P2_53, T_53;\n\n    // Đọc xâu P1, P2 và văn bản T từ đầu vào\n    getline(cin, P1_53);\n    getline(cin, P2_53);\n    getline(cin, T_53);\n\n    // Tìm vị trí xuất hiện đầu tiên của xâu P1 trong văn bản T\n    size_t pos = T_53.find(P1_53);\n\n    // Thay thế xâu P1 bằng xâu P2 trong văn bản T cho đến khi không còn xâu P1 nữa\n    while (pos != string::npos) {\n        T_53.replace(pos, P1_53.length(), P2_53);\n        pos = T_53.find(P1_53, pos + P2_53.length());\n    }\n\n    // In văn bản T sau khi thay thế\n    cout << T_53 << endl;\n\n    return 0;\n}\n"
        }
    },
    "Tuần 2": {
        "Bai1": {
            "Problem": "Problem: Week 2 - D\u00e3y fibonacci\n\nDescription\nGiven a fibonacci sequence a[0], a[1], a[2], ... in which:  a[0] = 0, a[1] = 1, a[n] = a[n-1] + a[n-2], for all n >= 2\nGiven  positive integer n, compute a[n-1].\n\nInput\nLine 1: contains a positive integer n (2 <= n <= 21)\nOutput\nWrite a[n-1]\n\nExample\nInput\n9\nOutput\n21",
            "Code": "#include <iostream>\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu 20215373\n    int n;\n    \n    // Input: Read a positive integer n (2 <= n <= 21)\n    cin >> n;\n    \n    // Initialize the first two Fibonacci numbers\n    int a_0_53 = 0;\n    int a_1_53 = 1;\n    \n    // Calculate the Fibonacci numbers up to n\n    for (int i = 2; i <= n; i++) {\n        // Calculate the next Fibonacci number and store it in a temporary variable\n        int temp_53 = a_0_53 + a_1_53;\n        \n        // Update a_0_53 and a_1_53 for the next iteration\n        a_0_53 = a_1_53;\n        a_1_53 = temp_53;\n    }\n    \n    // Output: Write a[n-1]\n    cout << a_0_53 << endl;\n    \n    return 0;\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 2 - Compute C_k_n\n\nDescription\nGiven two positive integers k and n. Compute C(k,n) which is the number of ways to select k objects from a given set of n objects.\n\nInput\nLine 1: two positive integers k and n (1 <= k,n <= 999)\nOutput\nWrite te value C(k,n) modulo 10\n9\n+7.\n\nExample\nInput\n3  5\nOutput\n10\n",
            "Code": "#include <iostream>\nusing namespace std;\n\nconst int MOD_53 = 1000000007;\n\nint main() {\n    int k_53, n_53;\n    //Phan Trung Hieu 20215373\n\n    // Input: Read two positive integers k and n\n    cin >> k_53 >> n_53;\n    \n    // Create a 2D array to store the values of C(k, n)\n    long long dp_53[100][100];\n    \n    // Calculate C(k, n) using dynamic programming\n    for (int i_53 = 0; i_53 <= k_53; i_53++) {\n        for (int j_53 = 0; j_53 <= n_53; j_53++) {\n            if (j_53 == 0 || i_53 == j_53) {\n                dp_53[i_53][j_53] = 1;\n            } else {\n                dp_53[i_53][j_53] = (dp_53[i_53 - 1][j_53 - 1] + dp_53[i_53][j_53 - 1]) % MOD_53;\n            }\n        }\n    }\n    \n    // Output: Write the value of C(k, n) modulo 10^9 + 7\n    cout << dp_53[k_53][n_53] << endl;\n    \n    return 0;\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 2 - Binary sequence generation\n\nDescription\nGiven an integer n, write a program that generates all the binary sequences of length n in a lexicographic order.\n\nInput\nLine 1: contains an integer n (1 <= n <= 20)\nOutput\nWrite binary sequences in a lexicographic ordder, eac sequence in a line\n\nExample\nInput\n3\nOutput\n000\n001\n010\n011\n100\n101\n110\n111",
            "Code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to generate binary sequences\nvoid generateBinarySequences_53(int n_53, string current_53) {\n    if (n_53 == 0) {\n        // If we have generated a binary sequence of length n, print it\n        cout << current_53 << endl;\n    } else {\n        // Append \"0\" and \"1\" to the current sequence and continue recursively\n        generateBinarySequences_53(n_53 - 1, current_53 + \"0\");\n        generateBinarySequences_53(n_53 - 1, current_53 + \"1\");\n    }\n}\n\nint main() {\n    int n_53;\n    //Phan Trung Hieu 20215373\n    // Input: Read an integer n\n    cin >> n_53;\n    \n    string current_53 = \"\";\n    \n    // Start the generation process\n    generateBinarySequences_53(n_53, current_53);\n    \n    return 0;\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 2 - Binary sequences generation without consecutive 11\n\nDescription\nGiven an integer n, write a program that generates all binary sequences without consecutive 11 in a lexicographic order.\n\nInput\nLine 1: contains an integer n (1 <= n <= 20)\nOutput\nWrite binary sequences in a lexicographic order, each sequence in a line\n\nExample\nInput\n3\nOutput\n000\n001\n010\n100\n101",
            "Code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Function to generate binary sequences\nvoid generateBinarySequences_53(int n_53, string current_53) {\n    if (n_53 == 0) {\n        // If we have generated a binary sequence of length n, print it\n        cout << current_53 << endl;\n    } else {\n        // Append \"0\" and \"1\" to the current sequence and continue recursively\n        generateBinarySequences_53(n_53 - 1, current_53 + \"0\");\n        generateBinarySequences_53(n_53 - 1, current_53 + \"1\");\n    }\n}\n\nint main() {\n    int n_53;\n    //Phan Trung Hieu 20215373\n    // Input: Read an integer n\n    cin >> n_53;\n    \n    string current_53 = \"\";\n    \n    // Start the generation process\n    generateBinarySequences_53(n_53, current_53);\n    \n    return 0;\n}\n",
            "PhanTrungHieu_20215373_Bai5.cpp": "#include <bits/stdc++.h> \nusing namespace std;\n\nvector<int> arr_53(20);          // To store the permutation\nint n_53;                         // The value of n\nvector<bool> isEmpty_53(20, true); // To keep track of available numbers\n\n// Function to check if a number is available for use in the permutation\nbool check_53(int num_53) {\n    return isEmpty_53[num_53];\n}\n\n// Function to print the current permutation\nvoid printResult_53() {\n    for (int i_53 = 0; i_53 < n_53; i_53++) {\n        cout << arr_53[i_53] << \" \";\n    }\n    cout << endl;\n}\n\n// Recursive function to generate permutations\nvoid solve_53(int num_53) {\n    if (num_53 == n_53) {\n        printResult_53(); // If the permutation is complete, print it\n        return;\n    }\n    for (int i_53 = 1; i_53 <= n_53; i_53++) {\n        if (check_53(i_53)) {\n            arr_53[num_53] = i_53;         // Place the number in the permutation\n            isEmpty_53[i_53] = false;   // Mark the number as used\n            solve_53(num_53 + 1);       // Recursively generate the next element\n            isEmpty_53[i_53] = true;    // Mark the number as available again for other permutations\n        }\n    }\n}\n\nint main() {\n    //Phan Trung Hieu 20215373\n    cin >> n_53; // Input: Read the value of n\n    solve_53(0); // Start generating permutations from index 0\n    return 0;\n}\n"
        },
        "Bai5": {
            "Problem": "Problem: Week 2 - Permutation generation\n\nDescription\nGiven an integer n, write a program to generate all permutations of 1, 2, ..., n in a lexicalgraphic order (elements of a permutation are separated by a SPACE character).\n\nExample\nInput \n3\nOutput\n1 2 3 \n1 3 2 \n2 1 3 \n2 3 1 \n3 1 2 \n3 2 1 ",
            "Code": "#include <bits/stdc++.h> \nusing namespace std;\n\nvector<int> arr_53(20);          // To store the permutation\nint n_53;                         // The value of n\nvector<bool> isEmpty_53(20, true); // To keep track of available numbers\n\n// Function to check if a number is available for use in the permutation\nbool check_53(int num_53) {\n    return isEmpty_53[num_53];\n}\n\n// Function to print the current permutation\nvoid printResult_53() {\n    for (int i_53 = 0; i_53 < n_53; i_53++) {\n        cout << arr_53[i_53] << \" \";\n    }\n    cout << endl;\n}\n\n// Recursive function to generate permutations\nvoid solve_53(int num_53) {\n    if (num_53 == n_53) {\n        printResult_53(); // If the permutation is complete, print it\n        return;\n    }\n    for (int i_53 = 1; i_53 <= n_53; i_53++) {\n        if (check_53(i_53)) {\n            arr_53[num_53] = i_53;         // Place the number in the permutation\n            isEmpty_53[i_53] = false;   // Mark the number as used\n            solve_53(num_53 + 1);       // Recursively generate the next element\n            isEmpty_53[i_53] = true;    // Mark the number as available again for other permutations\n        }\n    }\n}\n\nint main() {\n    //Phan Trung Hieu 20215373\n    cin >> n_53; // Input: Read the value of n\n    solve_53(0); // Start generating permutations from index 0\n    return 0;\n}\n"
        },
        "Bai6": {
            "Problem": "Problem: Week 2 - Count number of sudoku solutions\n\nDescription\nWrite a program to compute the number of sudoku solutions (fill the zero elements of a given partial sudoku table)\nFill numbers from 1, 2, 3, .., 9 to 9 x 9 table so that:\nNumbers of each row are distinct\nNumbers of each column are distinct\nNumbers on each sub-square 3 x 3 are distinct\n\nInput\nEach line i (i = 1, 2, ..., 9) contains elements of the i\nth\n row of the Sudoku table: elements are numbers from 0 to 9 (value 0 means the empty cell of the table)\nOutput\nWrite the number of solutions found\n\nExample\nInput\n0 0 3 4 0 0 0 8 9\n0 0 6 7 8 9 0 2 3\n0 8 0 0 2 3 4 5 6\n0 0 4 0 6 5 0 9 7\n0 6 0 0 9 0 0 1 4\n0 0 7 2 0 4 3 6 5\n0 3 0 6 0 2 0 7 8\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\nOutput\n64",
            "Code": "#include <iostream>\nusing namespace std;\n\nconst int N_53 = 9; // Size of the Sudoku board\n\nint board_53[N_53][N_53];\n\n// Function to check if it's safe to place a number in a given cell\nbool isSafe_53(int row_53, int col_53, int num_53) {\n    // Check if 'num' is not present in the current row and current column\n    for (int i_53 = 0; i_53 < N_53; i_53++) {\n        if (board_53[row_53][i_53] == num_53 || board_53[i_53][col_53] == num_53) {\n            return false;\n        }\n    }\n\n    // Check if 'num' is not present in the current 3x3 sub-grid\n    int startRow_53 = row_53 - row_53 % 3;\n    int startCol_53 = col_53 - col_53 % 3;\n    for (int i_53 = 0; i_53 < 3; i_53++) {\n        for (int j_53 = 0; j_53 < 3; j_53++) {\n            if (board_53[i_53 + startRow_53][j_53 + startCol_53] == num_53) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n// Function to count the number of Sudoku solutions using backtracking\nint countSudokuSolutions_53() {\n    for (int row_53 = 0; row_53 < N_53; row_53++) {\n        for (int col_53 = 0; col_53 < N_53; col_53++) {\n            if (board_53[row_53][col_53] == 0) {\n                int count_53 = 0;\n                for (int num_53 = 1; num_53 <= N_53; num_53++) {\n                    if (isSafe_53(row_53, col_53, num_53)) {\n                        board_53[row_53][col_53] = num_53;\n                        count_53 += countSudokuSolutions_53(); // Recursively count solutions\n                        board_53[row_53][col_53] = 0; // Backtrack\n                    }\n                }\n                return count_53;\n            }\n        }\n    }\n    return 1; // If all cells are filled, a solution is found\n}\n\nint main() {\n    //Phan Trung Hieu\n    // Input: Read the Sudoku board\n    for (int i_53 = 0; i_53 < N_53; i_53++) {\n        for (int j_53 = 0; j_53 < N_53; j_53++) {\n            cin >> board_53[i_53][j_53];\n        }\n    }\n\n    // Count the number of Sudoku solutions\n    int solutions_53 = countSudokuSolutions_53();\n\n    // Output: Print the number of solutions\n    cout << solutions_53 << endl;\n\n    return 0;\n}\n"
        },
        "Bai7": {
            "Problem": "Problem: Linear Integer Equation - coefficent 1\n\nDescription\nGiven two integer n and M. Write a program that generates all ordered collection (X1, X2, ..., Xn) such that: X1 + X2 + . . . + Xn = M\n\nInput\nLine 1: contains 2 integers n and M (2 <= n <= 10, 1 <= M <= 20)\nOutput\nWrite in each line X1, X2, ..., Xn separated by a SPACE character\n\nExample\nInput\n3  5\nOutput\n1 1 3\n1 2 2\n1 3 1\n2 1 2\n2 2 1\n3 1 1",
            "Code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N_53 = 10;\n\nvector<int> arr_53(MAX_N_53); // Array to store the current collection\nint n_53; // Number of elements in the collection\nint sum_53; // Desired sum of the collection\nint curSum_53 = 0; // Current sum of elements in the collection\n\n// Function to print the current collection\nvoid printResult_53() {\n    for (int i_53 = 0; i_53 < n_53; i_53++) {\n        cout << arr_53[i_53] << \" \";\n    }\n    cout << endl;\n}\n\n// Recursive function to generate collections\nvoid solve_53(int num_53) {\n    // If we have generated 'n' elements, check if the current sum is equal to the desired sum\n    if (num_53 == n_53) {\n        if (curSum_53 != sum_53) return; // If not, return and backtrack\n        printResult_53(); // If the sum matches, print the collection\n        return;\n    }\n\n    // Generate elements in the collection\n    for (int i_53 = 1; i_53 < sum_53; i_53++) {\n        if (i_53 + curSum_53 > sum_53) return; // If adding 'i' exceeds the desired sum, backtrack\n        arr_53[num_53] = i_53; // Set the current element to 'i'\n        curSum_53 += i_53; // Update the current sum\n        solve_53(num_53 + 1); // Recursively generate the next element in the collection\n        curSum_53 -= i_53; // Backtrack by subtracting 'i' from the current sum\n    }\n}\n\nint main() {\n    //Phan Trung Hieu 20215373\n    // Input: Read the values of 'n' and 'sum'\n    cin >> n_53 >> sum_53;\n\n    // Generate collections with the given sum\n    solve_53(0);\n\n    return 0;\n}\n"
        }
    },
    "Tuần 3": {
        "Bai1": {
            "Problem": "Problem: Week 3 - Simulation Stack\n\nDescription\nPerform a sequence of operations over a stack, each element is an integer:\nPUSH v: push a value v into the stack\nPOP: remove an element out of the stack and print this element to stdout (print NULL if the stack is empty)\n\nInput\nEach line contains a command (operration) of type \nPUSH  v\nPOP\nOutput\nWrite the results of POP operations (each result is written in a line)\n\nExample\nInput\nPUSH 1\nPUSH 2\nPUSH 3\nPOP\nPOP\nPUSH 4\nPUSH 5\nPOP\n#\nOutput\n3\n2\n5",
            "Code": "#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    stack<int> stack_53;\n    //Phan Trung Hieu 20215373\n    string line;\n    while (getline(cin, line)) {\n        if(line == \"#\") return 0; //end when \"#\"\n        if (line.find(\"PUSH\") != string::npos) {\n            // If the line contains \"PUSH\", it's a push operation\n            int value;\n            sscanf(line.c_str(), \"PUSH %d\", &value); // Extract the integer value\n            stack_53.push(value); // Push the value onto the stack\n        } else if (line == \"POP\") {\n            // If the line is \"POP\", it's a pop operation\n            if (!stack_53.empty()) {\n                int popped_value = stack_53.top(); // Get the top element\n                stack_53.pop(); // Remove the top element\n                cout << popped_value << endl; // Print the popped value\n            } else {\n                // Stack is empty\n                cout << \"NULL\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 3 - Simulation Queue\n\nDescription\nPerform a sequence of operations over a queue, each element is an integer:\nPUSH v: push a value v into the queue\nPOP: remove an element out of the queue and print this element to stdout (print NULL if the queue is empty)\n\nInput\nEach line contains a command (operration) of type\nPUSH  v\nPOP\nOutput\nWrite the results of POP operations (each result is written in a line)\n\nExample\nInput\nPUSH 1\nPUSH 2\nPUSH 3\nPOP\nPOP\nPUSH 4\nPUSH 5\nPOP\n#\nOutput\n1\n2\n3\n\nInput\nPUSH 1\nPOP\nPOP\nPUSH 4\nPOP\n#\nOutput\n1\nNULL\n4",
            "Code":"#include <iostream>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    queue<int> queue_53;\n    //Phan Trung Hieu 20215373\n    string line;\n    while (getline(cin, line)) {\n        if(line == \"#\") return 0; //end when \"#\"\n        if (line.find(\"PUSH\") != string::npos) {\n            // If the line contains \"PUSH\", it's a push operation\n            int value;\n            sscanf(line.c_str(), \"PUSH %d\", &value); // Extract the integer value\n            queue_53.push(value); // Push the value into the queue\n        } else if (line == \"POP\") {\n            // If the line is \"POP\", it's a pop operation\n            if (!queue_53.empty()) {\n                int popped_value = queue_53.front(); // Get the front element\n                queue_53.pop(); // Remove the front element\n                cout << popped_value << endl; // Print the popped value\n            } else {\n                // Queue is empty\n                cout << \"NULL\" << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 3 - Check Parenthesis\n\nDescription\nGiven a string containing only characters (, ), [, ] {, }. Write a program that checks whether the string is correct in expression.\n\nExample\n ([]{()}()[]): correct\n ([]{()]()[]): incorrect\nInput\nOne line contains the string (the length of the string is less than or equal to $10^6$)One line contains the string (the length of the string is less than or equal to 10\n6\n)\nOutput\nWrite 1 if the sequence is correct, and write 0, otherwise\n\nExample\nInput\n(()[][]{}){}{}[][]({[]()})\nOutput\n1",
            "Code": "#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string input_53;\n    //Phan Trung Hieu 20215373\n    getline(cin, input_53); // Read the input string\n\n    stack<char> parenthesesStack_53; // Create a stack to store opening symbols\n\n    // Iterate through each character in the input string\n    for (char c : input_53) {\n        if (c == '(' || c == '[' || c == '{') {\n            // If the character is an opening symbol, push it onto the stack\n            parenthesesStack_53.push(c);\n        } else if (c == ')' || c == ']' || c == '}') {\n            // If the character is a closing symbol, check if the stack is empty\n            if (parenthesesStack_53.empty()) {\n                // If the stack is empty, the string is incorrect\n                cout << \"0\" << endl;\n                return 0;\n            }\n\n            // Get the top element from the stack\n            char top = parenthesesStack_53.top();\n            parenthesesStack_53.pop(); // Pop the top element\n\n            // Check if the top element matches the current closing symbol\n            if ((c == ')' && top != '(') || (c == ']' && top != '[') || (c == '}' && top != '{')) {\n                // If there is a mismatch, the string is incorrect\n                cout << \"0\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    // After processing the entire string, check if the stack is empty\n    if (parenthesesStack_53.empty()) {\n        // If the stack is empty, the string is correct\n        cout << \"1\" << endl;\n    } else {\n        // If there are remaining elements in the stack, the string is incorrect\n        cout << \"0\" << endl;\n    }\n\n    return 0;\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 3 - WATER JUGS\n\nDescription\nThere are two jugs, a-litres jug and b-litres jug (a, b are positive integers). There is a pump with unlimited water. Given a positive integer c, how to get exactly c litres.\n\nInput\n   Line 1: contains positive integers a,   b,  c  (1 <= a, b, c <= 900)\nOutput\n  write the number of steps or write -1 (if no solution found)\n\nExample\nInput\n6  8  4\nOutput\n4",
            "Code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\n// Define a structure to represent the state of the jugs\nstruct State {\n    int x, y;\n    State(int x, int y) : x(x), y(y) {}\n};\n\n// Function to check if a state is valid (within the jug capacities)\nbool isValid(int x, int y, int a, int b) {\n    return x >= 0 && y >= 0 && x <= a && y <= b;\n}\n\nint main() {\n    int a, b, c;\n    cin >> a >> b >> c;\n    //Phan Trung Hieu 20215373\n    // Initialize variables and data structures\n    map<pair<int, int>, int> steps; // To store the steps required for each state\n    queue<State> q;\n\n    // Starting state with both jugs empty\n    State start(0, 0);\n    q.push(start);\n    steps[{0, 0}] = 0;\n\n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n\n        int x = current.x;\n        int y = current.y;\n\n        // If the desired amount 'c' is reached, print the steps and exit\n        if (x == c || y == c) {\n            cout << steps[{x, y}] << endl;\n            return 0;\n        }\n\n        // Fill jug a\n        if (x < a) {\n            int newX = a;\n            int newY = y;\n            if (!steps.count({newX, newY})) {\n                steps[{newX, newY}] = steps[{x, y}] + 1;\n                q.push(State(newX, newY));\n            }\n        }\n\n        // Fill jug b\n        if (y < b) {\n            int newX = x;\n            int newY = b;\n            if (!steps.count({newX, newY})) {\n                steps[{newX, newY}] = steps[{x, y}] + 1;\n                q.push(State(newX, newY));\n            }\n        }\n\n        // Empty jug a\n        if (x > 0) {\n            int newX = 0;\n            int newY = y;\n            if (!steps.count({newX, newY})) {\n                steps[{newX, newY}] = steps[{x, y}] + 1;\n                q.push(State(newX, newY));\n            }\n        }\n\n        // Empty jug b\n        if (y > 0) {\n            int newX = x;\n            int newY = 0;\n            if (!steps.count({newX, newY})) {\n                steps[{newX, newY}] = steps[{x, y}] + 1;\n                q.push(State(newX, newY));\n            }\n        }\n\n        // Pour water from jug a to jug b\n        if (x > 0 && y < b) {\n            int diff = min(x, b - y);\n            int newX = x - diff;\n            int newY = y + diff;\n            if (!steps.count({newX, newY})) {\n                steps[{newX, newY}] = steps[{x, y}] + 1;\n                q.push(State(newX, newY));\n            }\n        }\n\n        // Pour water from jug b to jug a\n        if (y > 0 && x < a) {\n            int diff = min(y, a - x);\n            int newX = x + diff;\n            int newY = y - diff;\n            if (!steps.count({newX, newY})) {\n                steps[{newX, newY}] = steps[{x, y}] + 1;\n                q.push(State(newX, newY));\n            }\n        }\n    }\n\n    // If no solution is found, print -1\n    cout << -1 << endl;\n\n    return 0;\n}\n"
        },
        "Bai5": {
            "Problem": "Problem: Week 3 - Tree manipulation & Traversal\n\nDescription\nM\u1ed7i n\u00fat tr\u00ean c\u00e2y c\u00f3 tr\u01b0\u1eddng id (identifier) l\u00e0 m\u1ed9t s\u1ed1 nguy\u00ean (id c\u1ee7a c\u00e1c n\u00fat tr\u00ean c\u00e2y \u0111\u00f4i m\u1ed9t kh\u00e1c nhau)\nTh\u1ef1c hi\u1ec7n 1 chu\u1ed7i c\u00e1c h\u00e0nh \u0111\u1ed9ng sau \u0111\u00e2y bao g\u1ed3m c\u00e1c thao t\u00e1c li\u00ean quan \u0111\u1ebfn x\u00e2y d\u1ef1ng c\u00e2y v\u00e0 duy\u1ec7t c\u00e2y\n\u00b7 MakeRoot u: T\u1ea1o ra n\u00fat g\u1ed1c u c\u1ee7a c\u00e2y\n\u00b7 Insert u v: t\u1ea1o m\u1edbi 1 n\u00fat u v\u00e0 ch\u00e8n v\u00e0o cu\u1ed1i danh s\u00e1ch n\u00fat con c\u1ee7a n\u00fat v (n\u1ebfu n\u00fat c\u00f3 id b\u1eb1ng v kh\u00f4ng t\u1ed3n t\u1ea1i ho\u1eb7c n\u00fat c\u00f3 id b\u1eb1ng u \u0111\u00e3 t\u1ed3n t\u1ea1i th\u00ec kh\u00f4ng ch\u00e8n th\u00eam m\u1edbi)\n\u00b7 PreOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 tr\u01b0\u1edbc\n\u00b7 InOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 gi\u1eefa\n\u00b7 PostOrder: in ra th\u1ee9 t\u1ef1 c\u00e1c n\u00fat trong ph\u00e9p duy\u1ec7t c\u00e2y theo th\u1ee9 t\u1ef1 sau\nD\u1eef li\u1ec7u: bao g\u1ed3m c\u00e1c d\u00f2ng, m\u1ed7i d\u00f2ng l\u00e0 1 trong s\u1ed1 c\u00e1c h\u00e0nh \u0111\u1ed9ng \u0111\u01b0\u1ee3c m\u00f4 t\u1ea3 \u1edf tr\u00ean, d\u00f2ng cu\u1ed1i d\u00f9ng l\u00e0 * (\u0111\u00e1nh d\u1ea5u s\u1ef1 k\u1ebft th\u00fac c\u1ee7a d\u1eef li\u1ec7u).\nK\u1ebft qu\u1ea3: ghi ra tr\u00ean m\u1ed7i d\u00f2ng, th\u1ee9 t\u1ef1 c\u00e1c n\u00fat \u0111\u01b0\u1ee3c th\u0103m trong ph\u00e9p duy\u1ec7t theo th\u1ee9 t\u1ef1 tr\u01b0\u1edbc, gi\u1eefa, sau c\u1ee7a c\u00e1c h\u00e0nh \u0111\u1ed9ng PreOrder, InOrder, PostOrder t\u01b0\u01a1ng \u1ee9ng \u0111\u1ecdc \u0111\u01b0\u1ee3c t\u1eeb d\u1eef li\u1ec7u \u0111\u1ea7u v\u00e0o\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\nMakeRoot 10\nInsert 11 10\nInsert 1 10\nInsert 3 10\nInOrder\nInsert 5 11\nInsert 4 11\nInsert 8 3\nPreOrder\nInsert 2 3\nInsert 7 3\nInsert 6 4\nInsert 9 4\nInOrder\nPostOrder\n*\nK\u1ebft qu\u1ea3\n11 10 1 3\n10 11 5 4 1 3 8\n5 11 6 4 9 10 1 8 3 2 7\n5 6 9 4 11 1 8 2 7 3 10",
            "Code": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n// Function to perform PreOrder traversal\nvoid PreOrder(map<int, vector<int>>& tree_53, int root_53) {\n    cout << root_53 << \" \"; // Print the current node\n    for (int child_53 : tree_53[root_53]) {\n        PreOrder(tree_53, child_53); // Recursively traverse the children\n    }\n}\n\n// Function to perform InOrder traversal\nvoid InOrder(map<int, vector<int>>& tree_53, int root_53) {\n    if (!tree_53[root_53].empty()) {\n        InOrder(tree_53, tree_53[root_53][0]); // Recursively traverse the leftmost child\n    }\n    cout << root_53 << \" \"; // Print the current node\n    for (int i = 1; i < tree_53[root_53].size(); i++) {\n        InOrder(tree_53, tree_53[root_53][i]); // Recursively traverse the remaining children\n    }\n}\n\n// Function to perform PostOrder traversal\nvoid PostOrder(map<int, vector<int>>& tree_53, int root_53) {\n    for (int child_53 : tree_53[root_53]) {\n        PostOrder(tree_53, child_53); // Recursively traverse the children\n    }\n    cout << root_53 << \" \"; // Print the current node\n}\n\nint main() {\n    map<int, vector<int>> tree_53; // Map to store the tree structure\n\n    int root_53 = 0; // Initialize with a dummy root\n    string action_53;\n    //Phan Trung Hieu 20215373\n    while (cin >> action_53) {\n        if (action_53 == \"MakeRoot\") {\n            cin >> root_53; // Make a new root\n        } else if (action_53 == \"Insert\") {\n            int u_53, v_53;\n            cin >> u_53 >> v_53;\n            tree_53[v_53].push_back(u_53); // Insert node u as a child of node v\n        } else if (action_53 == \"PreOrder\") {\n            PreOrder(tree_53, root_53); // Perform PreOrder traversal\n            cout << endl;\n        } else if (action_53 == \"InOrder\") {\n            InOrder(tree_53, root_53); // Perform InOrder traversal\n            cout << endl;\n        } else if (action_53 == \"PostOrder\") {\n            PostOrder(tree_53, root_53); // Perform PostOrder traversal\n            cout << endl;\n        } else if (action_53 == \"*\") {\n            break; // End of input\n        }\n    }\n\n    return 0;\n}\n"
        },
        "Bai6": {
            "Problem": "Problem: Week 3 - Family Tree\n\nDescription\nGiven a family tree represented by child-parent (c,p) relations in which c is a child of p. Perform queries about the family tree:\ndescendants <name>: return number of descendants of the given <name>\ngeneration <name>: return the number of generations of the descendants of the given <name>\nNote that: the total number of people in the family is less than or equal to 10\n4\n\nInput\nContains two blocks. The first block contains information about child-parent, including lines (terminated by a line containing ***), each line contains: <child> <parent> where <child> is a string represented the name of the child and <parent> is a string represented the name of the parent. The second block contains lines (terminated by a line containing ***), each line contains two string <cmd> and <param> where <cmd> is the command (which can be descendants or generation) and <param> is the given name of the person participating in the  query.\nOutput\nEach line is the result of a corresponding query.\n\nExample\nInput\nPeter Newman\nMichael Thomas\nJohn David\nPaul Mark\nStephan Mark\nPierre Thomas\nMark Newman\nBill David\nDavid Newman\nThomas Mark\n***\ndescendants Newman\ndescendants Mark\ndescendants David\ngeneration Mark\n***\nOutput\n10\n5\n2\n2",
            "Code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <sstream> // Include the necessary library for string streaming.\nusing namespace std;\n\nmap<string, vector<string>> familyTree_53; // Use \"familyTree_53\" instead of \"familyTree\" for consistency.\n\n// Function to count descendants using recursion.\nint countDescendants_53(const string &name) {\n    int descendants_53 = 0;\n    if (familyTree_53.find(name) != familyTree_53.end()) {\n        for (const string &child_53 : familyTree_53[name]) {\n            descendants_53 += 1 + countDescendants_53(child_53);\n        }\n    }\n    return descendants_53;\n}\n\n// Function to count generations of descendants using recursion.\nint countGenerations_53(const string &name) {\n    int generations_53 = 0;\n    if (familyTree_53.find(name) != familyTree_53.end()) {\n        for (const string &child_53 : familyTree_53[name]) {\n            generations_53 = max(generations_53, 1 + countGenerations_53(child_53));\n        }\n    }\n    return generations_53;\n}\n\nint main() {\n    string input_53;\n    //Phan Trung Hieu 20215373\n    // Read child-parent relationships.\n    while (true) {\n        getline(cin, input_53);\n        if (input_53 == \"***\") break;\n        string child_53, parent_53;\n        istringstream iss_53(input_53);\n        iss_53 >> child_53 >> parent_53;\n        familyTree_53[parent_53].push_back(child_53);\n    }\n\n    // Process queries.\n    while (true) {\n        getline(cin, input_53);\n        if (input_53 == \"***\") break;\n        string cmd_53, name_53;\n        istringstream iss_53(input_53);\n        iss_53 >> cmd_53 >> name_53;\n        if (cmd_53 == \"descendants\") {\n            int descendants_53 = countDescendants_53(name_53);\n            cout << descendants_53 << endl;\n        } else if (cmd_53 == \"generation\") {\n            int generations_53 = countGenerations_53(name_53);\n            cout << generations_53 << endl;\n        }\n    }\n\n    return 0;\n}\n"
        },
        "Bai7": {
            "Problem": "Problem: Week 3 - BST - Insertion and PreOrder Traversal\n\nDescription\nGiven a BST initialized by NULL. Perform a sequence of operations on a BST including:\ninsert k: insert a key k into the BST (do not insert if the key k exists)\nInput\n\u2022Each line contains command under the form: \u201cinsert k\u201d\n\u2022The input is terminated by a line containing #\nOutput\n\u2022Write the sequence of keys of nodes visited by the pre-order traversal (separated by a SPACE character)\n\nExample\nInput\ninsert 20\ninsert 10\ninsert 26\ninsert 7\ninsert 15\ninsert 23\ninsert 30\ninsert 3\ninsert 8\n#\nOutput\n20 10 7 3 8 15 26 23 30\n",
            "Code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n//Phan Trung Hieu 20215373\n// Definition of a BST node.\nstruct TreeNode_53 {\n    int val;\n    TreeNode_53* left;\n    TreeNode_53* right;\n\n    TreeNode_53(int value) : val(value), left(nullptr), right(nullptr) {}\n};\n\n// Function to insert a key into the BST.\nTreeNode_53* insert(TreeNode_53* root, int key) {\n    if (root == nullptr) {\n        return new TreeNode_53(key);\n    }\n\n    if (key < root->val) {\n        root->left = insert(root->left, key);\n    } else if (key > root->val) {\n        root->right = insert(root->right, key);\n    }\n\n    return root;\n}\n\n// Function to perform pre-order traversal and print the sequence of keys.\nvoid preOrderTraversal(TreeNode_53* root) {\n    if (root == nullptr) {\n        return;\n    }\n\n    cout << root->val << \" \";\n\n    preOrderTraversal(root->left);\n    preOrderTraversal(root->right);\n}\n\nint main() {\n    TreeNode_53* root = nullptr;\n\n    string command;\n    int key;\n\n    while (cin >> command) {\n        if (command == \"insert\") {\n            cin >> key;\n            root = insert(root, key);\n        } else if (command == \"#\") {\n            break;\n        }\n    }\n\n    preOrderTraversal(root);\n    cout << endl;\n\n    return 0;\n}\n"
        },
        "Bai8": {
            "Problem": "Problem: Insert at the middle of a sequence\n\nDescription\nGiven a sequence of integers a1, a2, ..., an. The element in the middle is defined to be the element at index n/2 if n is even, and n/2+1, otherwise.\nPerform a sequence of actions of the form:\nADD v: which add a value v right-after the element in the middle of an sequence a1, a2, ..., an. \nPRINT: print the sequence to stdout, elements are separated by a SPACE character\n \nInput\nLine 1: contains a positive integer n (1 <= n <= 100000)\nLine 2: contains n positive integers a1, a2, ..., an (1 <= ai <= 1000000)\nSubsequent lines (number of lines can be up to 100000), each line contains an action of above format\n\nOutput\nWrite (in each line) the result of the corresponding PRINT action\n\nExample\nInput \n2\n8 4 \nADD 6\nADD 5\nADD 4\nPRINT\nADD 2\nADD 4\nPRINT\n#\n\nOutput\n8 6 4 5 4\n8 6 4 4 2 5 4\n ",
            "Code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n_53;  // Input variable\n    cin >> n_53;\n    //Phan Trung Hieu 20215373\n    vector<int> sequence_53(n_53);  // Vector to store the sequence\n    for (int i_53 = 0; i_53 < n_53; ++i_53) {\n        cin >> sequence_53[i_53];\n    }\n\n    string action_53;\n    while (cin >> action_53) {\n        if (action_53 == \"#\") return 0;  // Stop the program if \"#\" is encountered\n        if (action_53 == \"ADD\") {\n            int value_53;\n            cin >> value_53;\n            int mid_index_53 = n_53 / 2 + (n_53 % 2);  // Calculate middle index\n            sequence_53.insert(sequence_53.begin() + mid_index_53, value_53);\n            n_53++;  // Increase the size of the sequence\n        } else if (action_53 == \"PRINT\") {\n            for (int i_53 = 0; i_53 < n_53; ++i_53) {\n                cout << sequence_53[i_53] << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n"
        },
        "Bai9": {
            "Problem": "Problem: Week 3 - Linked List Manipulation\n\nDescription\nVi\u1ebft ch\u01b0\u01a1ng tr\u00ecnh th\u1ef1c hi\u1ec7n c\u00f4ng vi\u1ec7c sau:\nX\u00e2y d\u1ef1ng danh s\u00e1ch li\u00ean k\u1ebft v\u1edbi c\u00e1c kh\u00f3a \u0111\u01b0\u1ee3c cung c\u1ea5p ban \u0111\u1ea7u l\u00e0 d\u00e3y a1, a2, \u2026, an, sau \u0111\u00f3 th\u1ef1c hi\u1ec7n c\u00e1c thao t\u00e1c tr\u00ean danh s\u00e1ch bao g\u1ed3m: th\u00eam 1 ph\u1ea7n t\u1eed v\u00e0o \u0111\u1ea7u, v\u00e0o cu\u1ed1i danh s\u00e1ch, ho\u1eb7c v\u00e0o tr\u01b0\u1edbc, v\u00e0o sau 1 ph\u1ea7n t\u1eed n\u00e0o \u0111\u00f3 trong danh s\u00e1ch, ho\u1eb7c lo\u1ea1i b\u1ecf 1 ph\u1ea7n t\u1eed n\u00e0o \u0111\u00f3 trong danh s\u00e1ch\n\nInput\nD\u00f2ng 1: ghi s\u1ed1 nguy\u00ean d\u01b0\u01a1ng n (1 <= n <= 1000)\nD\u00f2ng 2: ghi c\u00e1c s\u1ed1 nguy\u00ean d\u01b0\u01a1ng a1, a2, \u2026, an.\nC\u00e1c d\u00f2ng ti\u1ebfp theo l\u1ea7n l\u01b0\u1ee3t l\u00e0 c\u00e1c l\u1ec7nh \u0111\u1ec3 thao t\u00e1c (k\u1ebft th\u00fac b\u1edfi k\u00fd hi\u1ec7u #) v\u1edbi c\u00e1c lo\u1ea1i sau:\naddlast  k: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k v\u00e0o cu\u1ed1i danh s\u00e1ch (n\u1ebfu k ch\u01b0a t\u1ed3n t\u1ea1i)\naddfirst  k: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k v\u00e0o \u0111\u1ea7u danh s\u00e1ch (n\u1ebfu k ch\u01b0a t\u1ed3n t\u1ea1i)\naddafter  u  v: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng u v\u00e0o sau ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng v tr\u00ean danh s\u00e1ch (n\u1ebfu v \u0111\u00e3 t\u1ed3n t\u1ea1i tr\u00ean danh s\u00e1ch v\u00e0 u ch\u01b0a t\u1ed3n t\u1ea1i)\naddbefore  u  v: th\u00eam ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng  u v\u00e0o tr\u01b0\u1edbc ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng v tr\u00ean danh s\u00e1ch (n\u1ebfu v \u0111\u00e3 t\u1ed3n t\u1ea1i tr\u00ean danh s\u00e1ch v\u00e0 u c\u1ee7a t\u1ed3n t\u1ea1i)\nremove  k: lo\u1ea1i b\u1ecf ph\u1ea7n t\u1eed c\u00f3 key b\u1eb1ng k kh\u1ecfi danh s\u00e1ch\nreverse: \u0111\u1ea3o ng\u01b0\u1ee3c th\u1ee9 t\u1ef1 c\u00e1c ph\u1ea7n t\u1eed c\u1ee7a danh s\u00e1ch (kh\u00f4ng \u0111\u01b0\u1ee3c c\u1ea5p ph\u00e1t m\u1edbi c\u00e1c ph\u1ea7n t\u1eed, ch\u1ec9 \u0111\u01b0\u1ee3c thay \u0111\u1ed5i m\u1ed1i n\u1ed1i li\u00ean k\u1ebft)\nOutput\nGhi ra d\u00e3y kh\u00f3a c\u1ee7a danh s\u00e1ch thu \u0111\u01b0\u1ee3c sau 1 chu\u1ed7i c\u00e1c l\u1ec7nh thao t\u00e1c \u0111\u00e3 cho\n\nExample\nInput\n5\n5 4 3 2 1\naddlast 3\naddlast 10\naddfirst 1\naddafter 10 4\nremove 1\n#\n\nOutput\n5 4 3 2 10 ",
            "Code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Define a structure for the linked list node\nstruct Node_53 {\n    int key_53;\n    Node_53* next_53;\n    Node_53(int k) : key_53(k), next_53(nullptr) {}\n};\n\nNode_53* head_53;  // Head of the linked list\n\n// Check if a given key exists in the linked list\nbool keyExists_53(int key) {\n    Node_53* current_53 = head_53;\n    while (current_53 != nullptr) {\n        if (current_53->key_53 == key) {\n            return true;\n        }\n        current_53 = current_53->next_53;\n    }\n    return false;\n}\n\n// Add an element to the end of the linked list\nvoid addLast_53(int key) {\n    if (keyExists_53(key)) return;  // If the key already exists, do not add it\n    Node_53* newNode_53 = new Node_53(key);\n    if (head_53 == nullptr) {  // If the list is empty, add to the beginning\n        head_53 = newNode_53;\n    } else {\n        // Traverse to the end\n        Node_53* current_53 = head_53;\n        while (current_53->next_53 != nullptr) {\n            current_53 = current_53->next_53;\n        }\n        // Add the new element to the end\n        current_53->next_53 = newNode_53;\n    }\n}\n\n// Add an element to the beginning of the linked list\nvoid addFirst_53(int key) {\n    if (keyExists_53(key)) return;  // If the key already exists, do not add it\n    Node_53* newNode_53 = new Node_53(key);\n    // Add to the beginning\n    newNode_53->next_53 = head_53;\n    head_53 = newNode_53;\n}\n\n// Add an element after a specific key in the linked list\nvoid addAfter_53(int key, int target) {\n    if (keyExists_53(key)) return;  // If the key already exists, do not add it\n    Node_53* newNode_53 = new Node_53(key);\n    Node_53* current_53 = head_53;\n    // Traverse to the element with the target key\n    while (current_53 != nullptr) {\n        if (current_53->key_53 == target) break;\n        current_53 = current_53->next_53;\n    }\n    // Add the new element after the target key\n    if (current_53 != nullptr) {\n        newNode_53->next_53 = current_53->next_53;\n        current_53->next_53 = newNode_53;\n    }\n}\n\n// Add an element before a specific key in the linked list\nvoid addBefore_53(int key, int target) {\n    if (keyExists_53(key)) return;\n    Node_53* newNode_53 = new Node_53(key);\n    if (head_53 != nullptr) {\n        if (head_53->key_53 == target) {\n            newNode_53->next_53 = head_53;\n            head_53 = newNode_53;\n            return;\n        }\n    }\n    Node_53* current_53 = head_53;\n    while (current_53->next_53 != nullptr) {\n        if (current_53->next_53->key_53 == target) break;\n        current_53 = current_53->next_53;\n    }\n    if (current_53->next_53 != nullptr) {\n        newNode_53->next_53 = current_53->next_53;\n        current_53->next_53 = newNode_53;\n    }\n}\n\n// Remove elements with a specific key from the linked list\nvoid remove_53(int key) {\n    if (head_53 == nullptr) {\n        return;\n    }\n    while (head_53 != nullptr) {\n        if (head_53->key_53 == key) {\n            Node_53* tmp_53 = head_53;\n            head_53 = head_53->next_53;\n            delete tmp_53;\n        } else break;\n    }\n    if (head_53 == nullptr) return;\n    Node_53* current_53 = head_53;\n    do {\n        while (current_53->next_53 != nullptr) {\n            if (current_53->next_53->key_53 == key) break;\n            current_53 = current_53->next_53;\n        }\n        if (current_53->next_53 != nullptr) {\n            Node_53* temp_53 = current_53->next_53;\n            current_53->next_53 = current_53->next_53->next_53;\n            delete temp_53;\n        }\n    } while (current_53->next_53 != nullptr);\n}\n\n// Reverse the order of elements in the linked list\nvoid reverse_53() {\n    Node_53* prev_53 = nullptr;\n    Node_53* current_53 = head_53;\n    Node_53* next_53 = nullptr;\n    while (current_53 != nullptr) {\n        next_53 = current_53->next_53;\n        current_53->next_53 = prev_53;\n        prev_53 = current_53;\n        current_53 = next_53;\n    }\n    head_53 = prev_53;\n}\n\n// Print the linked list\nvoid printList_53() {\n    Node_53* current_53 = head_53;\n    while (current_53 != nullptr) {\n        cout << current_53->key_53 << \" \";\n        current_53 = current_53->next_53;\n    }\n}\n\nint main() {\n    int n_53, key_53;\n    cin >> n_53;\n    //Phan Trung Hieu 20215373\n    for (int i = 0; i < n_53; ++i) {\n        cin >> key_53;\n        addLast_53(key_53);\n    }\n    string command_53;\n    while (cin >> command_53) {\n        if (command_53 == \"addlast\") {\n            cin >> key_53;\n            addLast_53(key_53);\n        } else if (command_53 == \"addfirst\") {\n            cin >> key_53;\n            addFirst_53(key_53);\n        } else if (command_53 == \"addafter\") {\n            int u_53, v_53;\n            cin >> u_53 >> v_53;\n            addAfter_53(u_53, v_53);\n        } else if (command_53 == \"addbefore\") {\n            int u_53, v_53;\n            cin >> u_53 >> v_53;\n            addBefore_53(u_53, v_53);\n        } else if (command_53 == \"remove\") {\n            cin >> key_53;\n            remove_53(key_53);\n        } else if (command_53 == \"reverse\") {\n            reverse_53();\n        } else if (command_53 == \"#\") {\n            break;\n        }\n    }\n\n    printList_53();\n    return 0;\n}\n"
        }
    },
    "Tuần 4": {
        "Bai1": {
            "Problem": "Problem: Week 4 - Store & Search String\n\nDescription\nA database contains a sequence of key k1, k2, ..., kn which are strings (1<=n<=100000). Perform a sequence of actions of two kinds:\n\u00b7 find k: find and return 1 if k exists in the database, and return 0, otherwise\n\u00b7 insert k: insert a key k into the database and return 1 if the insertion is successful (k does not exist in the database) and return 0 if the insertion is failed (k exists in the database)\nNote that the length of any key is greater than 0 and less than or equal to 50.\n\nInput\nTwo blocks of information. The first block contains a key of (k1,k2,...,kn) in each line. The first block is terminated with a line containing *. The second block is a sequence of actions of two finds described above: each line contains 2 string: cmd and k in which cmd = find or insert and k is the key (parameter of the action). The second block is terminated with a line containing ***. Note that the number of actions can be up to 100000.\nOutput\nEach line contains the result (0 or 1) of the corresponding action.\n\nExample\nInput\ncomputer\nuniversity\nschool\ntechnology\nphone\n*\nfind school\nfind book\ninsert book\nfind algorithm\nfind book\ninsert book\n***\nOutput\n1\n0\n1\n0\n1\n0",
            "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    string tmp_53; \n    map<string, int> myMap_53; \n    //Phan Trung Hieu - 20215373\n    // First loop: Read and store strings until the user inputs \"*\".\n    while (true) {\n        cin >> tmp_53; // Read a string.\n        if (tmp_53 == \"*\") break; // If the string is \"*\", exit the loop.\n        myMap_53[tmp_53] += 1; // Increase the frequency count for 'tmp_53' in the map.\n    }\n\n    // Second loop: Continuously accept user input and respond to commands.\n    while (true) {\n        cin >> tmp_53; // Read the next command.\n\n        if (tmp_53 == \"***\") return 0; // If the command is \"***\", exit the program.\n\n        if (tmp_53 == \"find\") {\n            cin >> tmp_53; // Read the string to find in the map.\n            if (myMap_53[tmp_53]) cout << 1 << endl; // If the string is found, print 1.\n            else cout << 0 << endl; // If the string is not found, print 0.\n            continue;\n        }  \n        cin >> tmp_53; // Read the string to potentially add to the map.\n\n        if (myMap_53[tmp_53]) {\n            cout << 0 << endl; // If the string is already in the map, print 0.\n            continue;\n        }\n        cout << 1 << endl; // If the string is not in the map, print 1.\n        myMap_53[tmp_53] += 1; // Add the string to the map with a count of 1.\n    }\n\n    return 0;\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 4 - Hash Over Strings\n\nDescription\nGiven a string s[1\u2026k] which is a sequence of characters taken from {\u2018a\u2019, . . ., \u2018z\u2019}. Given a positive integer m, the hash code of s is defined by the formula:\nH(s) =  (s[1]*256k-1 + s[2]*256k-2 + . . . + s[k]*2560 ) mod m  (the contant integer m is a parameter)\nGiven a sequence of strings k1, k2, \u2026, kn, compute the corresponding hash codes\n\nInput\nLine 1: n and m (1 <= n,m <= 100000)\nLine i+1 (i = 1,2,\u2026,n): contains the string ki (the length of each string is less than or equal to 200)\nOutput\nEach line contains the corresponding hash code of n given strings\n\nExample\nInput\n4 1000\na\nab\nabc\nabcd\nOutput\n97\n930\n179\n924",
            "Code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu - 20215373\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n_53, m_53;  \n    string s_53;    \n    cin >> n_53 >> m_53;\n\n    // Precompute powers of 256 modulo m\n    long long power256_53 = 1;\n    long long powers_53[201]; // Assuming the maximum length of a string is 200\n\n    for (int i = 0; i <= 200; ++i) {\n        powers_53[i] = power256_53;\n        power256_53 = (power256_53 << 8) % m_53;\n    }\n\n    int optimize_53['z' + 1][201];\n\n    // Calculate optimized values for characters 'a' to 'z' for each position\n    for (int i = 'a'; i <= 'z'; i++)\n    {\n        for (int j = 0; j <= 200; ++j) {\n            optimize_53[i][j] = (powers_53[j] * i) % m_53;\n        }\n    }\n\n    int len_53, index_53;\n    long long hashCode_53;\n\n    // Process each test case\n    for (int i = 0; i < n_53; ++i) {\n        cin >> s_53;\n        len_53 = s_53.length();\n        hashCode_53 = 0;\n        index_53 = len_53 - 1;\n\n        // Calculate the hash code for the current input string\n        for (int j = 0; j < len_53; ++j) {\n            // Calculate the contribution of the current character\n            hashCode_53 += optimize_53[s_53[j]][index_53--];\n        }\n\n        // Output the hash code modulo m for the current test case\n        cout << hashCode_53 % m_53 << endl;\n    }\n\n    return 0; // End of the program _53\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 4 - Ki\u1ec3m tra xu\u1ea5t hi\u1ec7n\n\nDescription\nCho d\u00e3y s\u1ed1 nguy\u00ean A1, A2, . . . , An v\u1edbi m\u1ed7i s\u1ed1 nguy\u00ean Ai ki\u1ec3m tra xem c\u00f3 s\u1ed1 Aj n\u00e0o b\u1eb1ng Ai hay kh\u00f4ng v\u1edbi j<i.\n\nInput\nD\u00f2ng \u0111\u1ea7u ch\u1ee9a s\u1ed1 n (1\u2264n\u2264100,000)\nD\u00f2ng hai ch\u1ee9a nn s\u1ed1 nguy\u00ean A1, A2, ..., An (1\u2264Ai\u22641000,000,000)\nOutput\nGhi ra n d\u00f2ng, d\u00f2ng th\u1ee9 i in ra 1 n\u1ebfu t\u1ed3n t\u1ea1i Aj=Ai v\u1edbi j<i, ng\u01b0\u1ee3c l\u1ea1i in ra 0.\n\nExample\ninput\n5\n1 4 3 1 4\noutput\n0\n0\n0\n1\n1",
            "Code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu - 20215373\n    int n_53, tmp_53;\n    cin >> n_53;\n    map<int, int> myMap_53; // Create a map to store the frequency of integers, named 'myMap_53'.\n    for(int i_53 = 0; i_53 < n_53; i_53++) {\n        cin >> tmp_53; // Read an integer 'tmp_53'.\n\n        myMap_53[tmp_53] += 1; // Increment the frequency count for 'tmp_53' in the map.\n\n        if(myMap_53[tmp_53] > 1) {\n            cout << 1 << endl; // If 'tmp_53' has been seen before, print 1.\n            continue;\n        }\n        cout << 0 << endl; // If 'tmp_53' is seen for the first time, print 0.\n    }\n\n    return 0;\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 4 - Sum pair of sequence equal to a number\n\nDescription\nCho d\u00e3y a1, a2, ..., an trong \u0111\u00f3 c\u00e1c ph\u1ea7n t\u1eed \u0111\u00f4i m\u1ed9t kh\u00e1c nhau v\u00e0 1 gi\u00e1 tr\u1ecb nguy\u00ean d\u01b0\u01a1ng M. H\u00e3y \u0111\u1ebfm s\u1ed1 Q c\u00e1c c\u1eb7p (i,j) sao cho 1 <= i < j <= n v\u00e0 ai + aj = M.\n\nD\u1eef li\u1ec7u\nD\u00f2ng 1: ghi n v\u00e0 M (1 <= n, M <= 1000000)\nD\u00f2ng 2: ghi a1, a2, ..., an\nK\u1ebft qu\u1ea3\nGhi ra gi\u00e1 tr\u1ecb Q\n\nV\u00ed d\u1ee5\nD\u1eef li\u1ec7u\n5 6\n5 2 1 4 3\nK\u1ebft qu\u1ea3\n2",
            "Code": "\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    //Phan Trung Hieu - 20215373\n    int n_53, sum_53, tmp_53, count_53 = 0;\n    cin >> n_53 >> sum_53; \n\n    map<int, bool> myMap_53; // Create a map to store encountered integers.\n\n    for (int i_53 = n_53 - 1; i_53 >= 0; i_53--) {\n        cin >> tmp_53; // Read the next integer 'tmp_53'.\n\n        if (myMap_53[sum_53 - tmp_53]) {\n            count_53++; // If the complement of 'tmp_53' to reach 'sum_53' is found, increment 'count_53'.\n        }\n\n        myMap_53[tmp_53] = true; // Mark 'tmp_53' as encountered in the map.\n    }\n\n    cout << count_53; // Print the count of pairs that sum up to 'sum_53'.\n\n    return 0;\n}"
        }
    },
    "Tuần 5": {
        "Bai1": {
            "Problem": "Problem: Week 5 - Minimum Spanning Tree - Kruskal\n\nDescription\nGiven a undirected connected graph G=(V,E) where V={1,\u2026,N}. Each edge (u,v)\u2208E(u,v)\u2208E has weight w(u,v)w(u,v). Compute minimum spanning tree of G.\n\nInput\nLine 1: N and M (1\u2264N,M\u2264105) in which NN is the number of nodes and MM is the number of edges.\nLine i+1 (i=1,\u2026,M): contains 3 positive integers u, v, and w where w is the weight of edge (u,v)\nOutput\nWrite the weight of the minimum spanning tree found.\n\nExample\nInput\n5 8\n1 2 1\n1 3 4\n1 5 1\n2 4 2\n2 5 1\n3 4 3\n3 5 3\n4 5 2\nOutput\n7",
            "Code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge_53 {\n    int u_53, v_53, weight_53;\n};\n\n// Function to compare edges based on their weight\nbool compareEdges_53(const Edge_53 &a_53, const Edge_53 &b_53) {\n    return a_53.weight_53 < b_53.weight_53;\n}\n\nvector<int> parent_53;\n\n// Function to find the parent (representative) of a set\nint find_53(int v_53) {\n    if (parent_53[v_53] == v_53) return v_53;\n    return parent_53[v_53] = find_53(parent_53[v_53]);\n}\n\n// Function to union two sets by updating their parent\nvoid unionSets_53(int a_53, int b_53) {\n    a_53 = find_53(a_53);\n    b_53 = find_53(b_53);\n    if (a_53 != b_53) {\n        parent_53[b_53] = a_53;\n    }\n}\n\nint main() {\n    int N_53, M_53;\n    cin >> N_53 >> M_53;  // Read the number of nodes and edges from input\n    //Phan Trung Hieu - 20215373\n    vector<Edge_53> edges_53(M_53);\n\n    for (int i = 0; i < M_53; ++i) {\n        cin >> edges_53[i].u_53 >> edges_53[i].v_53 >> edges_53[i].weight_53;  // Read edge data\n    }\n\n    sort(edges_53.begin(), edges_53.end(), compareEdges_53);  // Sort the edges by weight\n\n    parent_53.resize(N_53 + 1);\n\n    for (int i = 1; i <= N_53; ++i) {\n        parent_53[i] = i;  // Initialize each node as a separate set\n    }\n\n    int minimumSpanningTreeWeight_53 = 0;\n\n    for (const Edge_53 &edge_53 : edges_53) {\n        if (find_53(edge_53.u_53) != find_53(edge_53.v_53)) {\n            unionSets_53(edge_53.u_53, edge_53.v_53);  // Union two sets\n            minimumSpanningTreeWeight_53 += edge_53.weight_53;\n        }\n    }\n\n    cout << minimumSpanningTreeWeight_53 << endl;  // Output the minimum spanning tree weight\n\n    return 0;\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 5 - List order of nodes visited by a DFS\n\nDescription\nGiven a undirected graph =(V,E) in which V = {1,2,..,n} is the set of nodes. Write a program that visit nodes of G by a DFS (consider a lexicorgraphic order of nodes).\n\nInput\nLine 1: contains 2 integers n and m (1 <= n,m <= 100000)\nLine i+1: contains u and v which are two end-points of the ith edge\n\nOutput\nSequence of nodes visited by DFS\n\nExample\nInput\n7 12\n1 2\n1 3\n2 3\n2 4\n2 7\n3 5 \n3 7\n4 5\n4 6\n4 7\n5 6\n5 7 \nOutput\n1 2 3 5 4 6 7",
            "Code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to perform Depth-First Search (DFS) on the graph\nvoid dfs_53(int node, vector<vector<int>>& graph_53, vector<bool>& visited_53) {\n    cout << node << \" \";  // Output the current node\n    visited_53[node] = true;  // Mark the current node as visited\n\n    // Visit all unvisited neighbors of the current node\n    for (int neighbor : graph_53[node]) {\n        if (!visited_53[neighbor]) {\n            dfs_53(neighbor, graph_53, visited_53);\n        }\n    }\n}\n\nint main() {\n    int n_53, m_53;\n    cin >> n_53 >> m_53;  // Read the number of nodes and edges from input\n    //Phan Trung Hieu - 20215373\n    vector<vector<int>> graph_53(n_53 + 1);  // Create an adjacency list to represent the graph\n\n    for (int i = 0; i < m_53; ++i) {\n        int u_53, v_53;\n        cin >> u_53 >> v_53;\n        graph_53[u_53].push_back(v_53);  // Add the edge to the adjacency list\n        graph_53[v_53].push_back(u_53);  // Since it's an undirected graph, add the edge in both directions\n    }\n\n    for (int i = 1; i <= n_53; ++i) {\n        sort(graph_53[i].begin(), graph_53[i].end());  // Sort the neighbors of each node for lexicographic order\n    }\n\n    vector<bool> visited_53(n_53 + 1, false);  // Initialize a boolean array to track visited nodes\n\n    for (int i = 1; i <= n_53; ++i) {\n        if (!visited_53[i]) {\n            dfs_53(i, graph_53, visited_53);  // Perform DFS from unvisited nodes\n        }\n    }\n\n    cout << endl;  // Output a newline after visiting all nodes\n\n    return 0;\n}\n"
        },
        "Bai3": {
            "Problem": "Problem: Week 5 - Sequence of nodes visited by BFS\n\nDescription\nGiven undirected graph G = (V,E) in which V = {1, 2, ..., n} is the set of nodes, and E is the set of m edges.\nWrite a program that computes the sequence of nodes visited using a BFS algorithm (the nodes are considered in a lexicographic order)\n\nInput\nLine 1: contains 2 integers n and m which are the number of nodes and the number of edges\nLine i+1 (i = 1, ..., m): contains 2 positive integers u and v which are the end points of the ith edge\n\nOutput\nWrite the sequence of nodes visited by a BFS procedure (nodes a are separated by a SPACE character)\nExample\n\nInput\n6 7\n2 4\n1 3\n3 4\n5 6\n1 2\n3 5\n2 3\n\nOutput\n1 2 3 4 5 6",
            "Code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to perform Breadth-First Search (BFS) on the graph\nvoid bfs_53(int start, vector<vector<int>>& graph_53, vector<bool>& visited_53) {\n    queue<int> q;\n    q.push(start);\n    visited_53[start] = true;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        cout << node << \" \";  // Output the current node\n\n        // Visit all unvisited neighbors of the current node\n        for (int neighbor : graph_53[node]) {\n            if (!visited_53[neighbor]) {\n                q.push(neighbor);\n                visited_53[neighbor] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int n_53, m_53;\n    cin >> n_53 >> m_53;  // Read the number of nodes and edges from input\n    //Phan Trung Hieu - 20215373\n    vector<vector<int>> graph_53(n_53 + 1);  // Create an adjacency list to represent the graph\n\n    for (int i = 0; i < m_53; ++i) {\n        int u_53, v_53;\n        cin >> u_53 >> v_53;\n        graph_53[u_53].push_back(v_53);  // Add the edge to the adjacency list\n        graph_53[v_53].push_back(u_53);  // Since it's an undirected graph, add the edge in both directions\n    }\n\n    for (int i = 1; i <= n_53; ++i) {\n        sort(graph_53[i].begin(), graph_53[i].end());  // Sort the neighbors of each node for lexicographic order\n    }\n\n    vector<bool> visited_53(n_53 + 1, false);  // Initialize a boolean array to track visited nodes\n\n    for (int i = 1; i <= n_53; ++i) {\n        if (!visited_53[i]) {\n            bfs_53(i, graph_53, visited_53);  // Perform BFS from unvisited nodes\n        }\n    }\n\n    cout << endl;  // Output a newline after visiting all nodes\n\n    return 0;\n}\n"
        },
        "Bai4": {
            "Problem": "Problem: Week 5 - Hamiton Cycle\n\nDescription\nGiven an undirected graph G = (V,E). Write a program to check if G is a Hamiltonian graph.\n\nInput\nLine 1: a positive integer T (number of graphs)\nSubsequent lines are information about T graphs, each has the following format:\nLine 1: n and m (number of nodes and edges)\nLine i+1 (i = 1, 2, ..., m): u and v : two end points of the ith edge\nOutput\nIn the ith line, write 1 if the corresponding is a Hamiltonian graph, and write 0, otherwise\n\nExample\nInput\n2\n5 5\n1 2\n1 3\n2 4\n2 5\n3 5\n7 13\n1 3\n1 5\n1 7\n2 4\n2 5\n2 6\n3 4\n3 5 \n3 7\n4 6\n4 7\n5 7\n6 7\n\nOutput\n0\n1",
            "Code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Function to check if moving to node v is valid\nbool is_valid_move_53(int v_53, int pos_53, const vector<vector<int>>& graph_53, vector<int>& path_53) {\n    // Check if there is an edge from the previous node to the current node\n    if (graph_53[path_53[pos_53 - 1]][v_53] == 0) {\n        return false;\n    }\n\n    // Check if the node has already been visited\n    if (find(path_53.begin(), path_53.end(), v_53) != path_53.end()) {\n        return false;\n    }\n\n    return true;\n}\n\n// Utility function for the Hamiltonian Path problem\nbool hamiltonian_util_53(int pos_53, const vector<vector<int>>& graph_53, vector<int>& path_53) {\n    int num_nodes_53 = graph_53.size();\n    if (pos_53 == num_nodes_53) {\n        // Check if there is an edge from the last node to the starting node\n        if (graph_53[path_53[pos_53 - 1]][path_53[0]] == 1) {\n            return true; // A Hamiltonian path exists\n        } else {\n            return false; // No Hamiltonian path\n        }\n    }\n\n    for (int v_53 = 1; v_53 < num_nodes_53; ++v_53) {\n        if (is_valid_move_53(v_53, pos_53, graph_53, path_53)) {\n            path_53[pos_53] = v_53;\n            if (hamiltonian_util_53(pos_53 + 1, graph_53, path_53)) {\n                return true; // Continue with the path\n            }\n            path_53[pos_53] = -1; // Backtrack and explore other paths\n        }\n    }\n\n    return false; // No Hamiltonian path found\n}\n\n// Function to check if a Hamiltonian Path exists in the graph\nbool is_hamiltonian_53(const vector<vector<int>>& graph_53) {\n    int num_nodes_53 = graph_53.size();\n    vector<int> path_53(num_nodes_53, -1);\n    path_53[0] = 0; // Start from the first node\n\n    if (!hamiltonian_util_53(1, graph_53, path_53)) {\n        return false; // No Hamiltonian path found\n    } else {\n        return true; // A Hamiltonian path exists\n    }\n}\n\nint main() {\n    int T_53;\n    cin >> T_53; // Read the number of test cases\n    //Phan Trung Hieu - 20215373\n    for (int t_53 = 0; t_53 < T_53; ++t_53) {\n        int num_nodes_53, num_edges_53;\n        cin >> num_nodes_53 >> num_edges_53;\n        vector<vector<int>> graph_53(num_nodes_53, vector<int>(num_nodes_53, 0));\n\n        for (int i = 0; i < num_edges_53; ++i) {\n            int u_53, v_53;\n            cin >> u_53 >> v_53;\n            graph_53[u_53 - 1][v_53 - 1] = 1; // Mark the presence of an edge\n            graph_53[v_53 - 1][u_53 - 1] = 1; // Since it's an undirected graph, mark the edge in both directions\n        }\n\n        int result_53 = is_hamiltonian_53(graph_53) ? 1 : 0; // Check if a Hamiltonian path exists\n        cout << result_53 << endl; // Output the result (1 if a Hamiltonian path exists, 0 otherwise)\n    }\n\n    return 0;\n}\n"
        }
    },
    "Tuần 6": {
        "Bai1": {
            "Problem": "Problem: Week 6 - Max Flow\n\nDescription\nGiven a network G = (V, E) which is a directed weighted graph. Node s is the source and node t is the target. c(u,v) is the capacity of the arc (u,v). Find the maximum flow on G.\nInput\n\u2022Line 1: two positive integers N and M (1 <= N <= 104, 1 <= M <= 106)\n\u2022Line 2: contains 2 positive integers s and t\n\u2022Line i+2 (I = 1,. . ., M): contains two positive integers u and v which are endpoints of ith arc\n\nOutput\n  Write the value of the max-flow found\n\nExample\nInput\n7 12\n6 7\n1 7 7\n2 3 6\n2 5 6\n3 1 6\n3 7 11\n4 1 7\n4 2 4\n4 5 5\n5 1 4\n5 3 4\n6 2 8\n6 4 10\nOutput\n17\n",
            "Code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nconst int MAX_N_53 = 10000;\nconst int MAX_M_53 = 1000000;\nconst int INF_53 = 1e9;\n\nstruct Edge_53 {\n    int to_53, capacity_53, flow_53; // Variables ending with _53.\n};\n\nvector<Edge_53> graph[MAX_N_53];\nvector<int> parent_53;\n\nint fordFulkerson_53(int source_53, int sink_53) {\n    int maxFlow_53 = 0;\n\n    while (true) {\n        parent_53.assign(MAX_N_53, -1);\n        queue<pair<int, int>> q_53;\n        q_53.push({source_53, INF_53});\n\n        while (!q_53.empty()) {\n            int curNode_53 = q_53.front().first;\n            int curFlow_53 = q_53.front().second;\n            q_53.pop();\n\n            if (curNode_53 == sink_53) {\n                maxFlow_53 += curFlow_53;\n                int node_53 = sink_53;\n                while (node_53 != source_53) {\n                    int prevNode_53 = parent_53[node_53];\n                    for (Edge_53 &edge_53 : graph[prevNode_53]) {\n                        // Find the edge from the parent to the current node.\n                        if (edge_53.to_53 != node_53) {\n                            continue; // Skip other edges.\n                        } else {\n                            edge_53.flow_53 += curFlow_53; // Increase flow on this edge.\n                            for (Edge_53 &reverseEdge_53 : graph[node_53]) {\n                                // Find the corresponding reverse edge.\n                                if (reverseEdge_53.to_53 != prevNode_53) {\n                                    continue; // Skip other reverse edges.\n                                } else {\n                                    reverseEdge_53.flow_53 -= curFlow_53; // Decrease reverse flow.\n                                    break;\n                                }\n                            }\n                            break; // Break the loop after updating the flow.\n                        }\n                    }\n                    node_53 = prevNode_53;\n                }\n                break;\n            }\n\n            for (Edge_53 &edge_53 : graph[curNode_53]) {\n                int capacity_53 = edge_53.capacity_53 - edge_53.flow_53;\n                int nextNode_53 = edge_53.to_53;\n                if (capacity_53 <= 0 || parent_53[nextNode_53] != -1) continue; // Skip invalid or visited nodes.\n                int minFlow_53 = min(curFlow_53, capacity_53);\n                parent_53[nextNode_53] = curNode_53;\n                q_53.push({nextNode_53, minFlow_53}); // Enqueue the next node and update its flow.\n            }\n        }\n\n        if (parent_53[sink_53] == -1) {\n            break; // If no augmenting path is found, exit the loop.\n        }\n    }\n\n    return maxFlow_53; // Return the maximum flow.\n}\n\nint main() {\n    //Phan Trung Hieu - 20215373\n    int N_53, M_53;\n    cin >> N_53 >> M_53;\n\n    int source_53, sink_53;\n    cin >> source_53 >> sink_53;\n\n    for (int i_53 = 0; i_53 < M_53; i_53++) {\n        int u_53, v_53, capacity_53;\n        cin >> u_53 >> v_53 >> capacity_53;\n\n        graph[u_53].push_back({v_53, capacity_53, 0});\n        graph[v_53].push_back({u_53, 0, 0}); // Create reverse edges with zero capacity for the residual graph.\n    }\n\n    int maxFlow_53 = fordFulkerson_53(source_53, sink_53); // Find the maximum flow.\n    cout << maxFlow_53 << endl; // Print the maximum flow.\n\n    return 0;\n}"
        },
        "Bai2": {
            "Problem": "Problem: Week 6 - Shortest Path between 2 nodes on a directed graph with non-negative weights\n\nDescription\nGiven a directed graph G = (V,E) in which V = {1,2,...,n) is the set of nodes. Each arc (u,v) has a non-negative weight w(u,v). Given two nodes s and t of G. Find the shortest path from s to t on G.\n\nInput\nLine 1: contains two integers n and m which are the number of nodes and the number of arcs of G (1 <= n <= 100000)\nLine i + 1(i = 1,2,...,m): contains 3 integers u, v, w in which w is the weight of arc(u,v) (0 <= w <= 100000)\nLine m+2: contains two integers s and t\n\nOutput\nWrite the weight of the shortest path found or write -1 if no path from s to t was found\n\nExample\nInput\n5 7\n2 5 87\n1 2 97\n4 5 78\n3 1 72\n1 4 19\n2 3 63\n5 1 18\n1 5\n\nOutput\n97",
            "Code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF_53 = numeric_limits<int>::max();\n\nstruct Edge_53 {\n    int to_53, weight_53; // Variables ending with _53.\n};\n\nint shortestPath_53(const vector<vector<Edge_53>>& graph_53, int start_53, int end_53) {\n    int n_53 = graph_53.size();\n    vector<int> distances_53(n_53, INF_53);\n    distances_53[start_53] = 0;\n\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq_53;\n    pq_53.push({0, start_53});\n\n    while (!pq_53.empty()) {\n        int current_dist_53 = pq_53.top().first;\n        int current_node_53 = pq_53.top().second;\n        pq_53.pop();\n\n        // If the current node is the destination, return the distance.\n        if (current_node_53 == end_53) {\n            return current_dist_53; // Shortest path distance found.\n        }\n\n        // If the current distance is less than or equal to the known distance to this node, explore its neighbors.\n        if (current_dist_53 <= distances_53[current_node_53]) {\n            for (const Edge_53& edge_53 : graph_53[current_node_53]) {\n                int neighbor_53 = edge_53.to_53;\n                int distance_53 = current_dist_53 + edge_53.weight_53;\n\n                // If the new distance is shorter, update it and add the neighbor to the priority queue.\n                if (distance_53 < distances_53[neighbor_53]) {\n                    distances_53[neighbor_53] = distance_53;\n                    pq_53.push({distance_53, neighbor_53});\n                }\n            }\n        }\n    }\n\n    // If no path is found, return -1.\n    return -1; // No valid path found.\n}\n\nint main() {\n    int n_53, m_53;\n    cin >> n_53 >> m_53;\n    //Phan Trung Hieu - 20215373\n    vector<vector<Edge_53>> graph_53(n_53);\n\n    for (int i_53 = 0; i_53 < m_53; i_53++) {\n        int u_53, v_53, w_53;\n        cin >> u_53 >> v_53 >> w_53;\n        graph_53[u_53 - 1].push_back({v_53 - 1, w_53});\n    }\n\n    int s_53, t_53;\n    cin >> s_53 >> t_53;\n    s_53--; t_53--;\n\n    int shortest_path_53 = shortestPath_53(graph_53, s_53, t_53);\n\n    cout << shortest_path_53 << endl; // Output the shortest path distance.\n\n    return 0;\n}"
        },
        "Bai3": {
            "Problem": "Problem: Week 6 - All pair shortest paths\n\nDescription\nGiven a directed graph G = (V, E) in which V = {1, 2, ..., n} is the set of nodes, and w(u,v) is the weight (length) of the arc(u,v). Compute d(u,v) - the length of the shortest path from u to v in G, for all u,v in V.\n\nInput\nLine 1: contains 2 positive integers n and m (1 <= n,m <= 10000)\nLine i+1 (i = 1, 2, ..., m): contains 3 positive integers u, v, w in which w is the weight of the arc (u,v) (1 <= w <= 1000)\nOutput\nLine i (i = 1, 2, ..., n): wirte the ith row of the matrix d (if there is not any path from node i to node j, then d(i,j) = -1)\n\nExample\nInput\n4 9 \n1 2 9 \n1 3 7 \n1 4 2 \n2 1 1 \n2 4 5 \n3 4 6 \n3 2 2 \n4 1 5 \n4 2 8\nOutput\n0 9 7 2  \n1 0 8 3  \n3 2 0 5  \n5 8 12 0",
            "Code": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nconst int INF_53 = numeric_limits<int>::max();\n\nint main() {\n    int n_53, m_53;\n    cin >> n_53 >> m_53;\n    //Phan Trung Hieu - 20215373\n    // Create a matrix to store distances, initialized to INF.\n    vector<vector<int>> distance_53(n_53, vector<int>(n_53, INF_53));\n\n    // Set the diagonal to 0 since the distance from a node to itself is 0.\n    for (int i_53 = 0; i_53 < n_53; i_53++) {\n        distance_53[i_53][i_53] = 0;\n    }\n\n    // Read the input and update the distance matrix with given edge weights.\n    for (int i_53 = 0; i_53 < m_53; i_53++) {\n        int u_53, v_53, w_53;\n        cin >> u_53 >> v_53 >> w_53;\n        distance_53[u_53 - 1][v_53 - 1] = w_53;\n    }\n\n    // Use the Floyd-Warshall algorithm to calculate shortest paths.\n    for (int k_53 = 0; k_53 < n_53; k_53++) {\n        for (int i_53 = n_53 - 1; i_53 >= 0; i_53--) {\n            for (int j_53 = 0; j_53 < n_53; j_53++) {\n                if (distance_53[i_53][k_53] == INF_53 || distance_53[k_53][j_53] == INF_53) {\n                    continue;\n                }\n                distance_53[i_53][j_53] = min(distance_53[i_53][j_53], distance_53[i_53][k_53] + distance_53[k_53][j_53]);\n            }\n        }\n    }\n\n    // Output the calculated shortest path distances, or -1 if no path exists.\n    for (int i_53 = 0; i_53 < n_53; i_53++) {\n        for (int j_53 = 0; j_53 < n_53; j_53++) {\n            if (distance_53[i_53][j_53] != INF_53) {\n                cout << distance_53[i_53][j_53] << \" \";\n            } else {\n                cout << -1 << \" \";\n            }\n        }\n        cout << endl;\n    }\n\n    return 0;\n}"
        }
    },
    "Tuần 7": {
        "Bai1": {
            "Problem": "Problem: Week 7 - Bank Transaction\n\nDescription\nThe data about bank transactions consists of a sequence of transactions: the information of each transaction has the following format:\n                                                                    <from_account>  <to_account>   <money>   <time_point>   <atm>\nIn which:\n\u2022\t<from_account>: the account from which money is transferred (which is a string of length from 6 to 20 )\n\u2022\t<to_account>: the account which receives money in the transaction (which is a string of length from 6 to 20)\n\u2022\t<money>: amount of money transferred in the transaction (which is an integer from 1 to 10000)\n\u2022\t<time_point>: the time point at which the transaction is performed, it is a string under the format HH:MM:SS  (hour: minute: second)\n\u2022\t<atm>: the code of the ATM where the transaction is taken (a string of length from 3 to 10)\nExample: T00112233445 T001234002 2000 08:36:25 BIDV (at the ATM BIDV, account T00112233445 transfers 2000$ to account T001234002 at time point 08:36:25 (08 hour, 36 minutes, 25 seconds) \nA transaction cycle of length k starting from account a1 is defined to be a sequence of distinct account a1, a2, \u2026, ak  in which there are transactions from account a1 to a2, from a2 to a3, \u2026, from ak to a1.\nWrite a program that process the following queries: \n?number_transactions: compute the total number of transactions of the data\n?total_money_transaction: compute the total amount of money of transactions  \n?list_sorted_accounts: compute the sequence of bank accounts (including sending and receiving accounts) appearing in the transaction (sorted in an increasing (alphabetical) order)  \n?total_money_transaction_from <account>: compute the total amount of money transferred from the account <account>  \n?inspect_cycle <account> k : return 1 if there is a transaction cycle of length k, starting from <account>, and return 0, otherwise\n\nInput (stdin)\nThe input consists of 2 blocks of information: the data block and the query block\n\u2022\tThe data block consists of lines:\no\tEach line contains the information about a transaction described above\no\tThe data is terminated by a line containing #\n\u2022\tThe query block consists of lines:\no\tEach line is a query described above\no\tThe query block is terminated by a line containing #\n\nOutput (stdout)\n\u2022\tPrint to stdout (in each line) the result of each query described above\n\nExample\nInput\nT000010010 T000010020 1000 10:20:30 ATM1\nT000010010 T000010030 2000 10:02:30 ATM2\nT000010010 T000010040 1500 09:23:30 ATM1\nT000010020 T000010030 3000 08:20:31 ATM1\nT000010030 T000010010 4000 12:40:00 ATM2\nT000010040 T000010010 2000 10:30:00 ATM1\nT000010020 T000010040 3000 08:20:31 ATM1\nT000010040 T000010030 2000 11:30:00 ATM1\nT000010040 T000010030 1000 18:30:00 ATM1\n#\n?number_transactions\n?total_money_transaction\n?list_sorted_accounts\n?total_money_transaction_from T000010010\n?inspect_cycle T000010010 3\n#\nOutput\n9\n19500\nT000010010 T000010020 T000010030 T000010040\n4500\n1",
            "Code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\n// Struct to represent a financial transaction\ntypedef struct Transaction_53\n{\n    string from_account_53;\n    string to_account_53;\n    int money_53;\n    string time_point_53;\n    string atm_53;\n} Transaction_53;\n\n// Adjacency list representation for the graph\nmap<string, vector<string>> adj_53;\n// Mark nodes as visited during DFS\nmap<string, bool> visited_53;\n\n// Depth-First Search (DFS) to check for cycles\nbool DFS_53(string account_53, string start_53, int depth_53, int k_53)\n{\n    if (depth_53 != k_53)\n    {\n        visited_53[account_53] = true;\n        for (string next_account_53 : adj_53[account_53])\n        {\n            if (visited_53[next_account_53] || !DFS_53(next_account_53, start_53, depth_53 + 1, k_53))\n            {\n                continue;\n            }\n            return true;\n        }\n        visited_53[account_53] = false;\n        return false;\n    }\n    return find(adj_53[account_53].begin(), adj_53[account_53].end(), start_53) != adj_53[account_53].end();\n}\n\nint main()\n{\n    //Phan Trung Hieu - 20215373\n    // Disable synchronization between C and C++ streams for performance\n    ios::sync_with_stdio(false);\n    // Untie cin from cout for performance\n    cin.tie(0);\n\n    // Vector to store financial transactions\n    vector<Transaction_53> transactions_53;\n    string s_53;\n    // Map to store the total money transferred from each account\n    map<string, int> from_accounts_53;\n    // Set to store unique account names\n    set<string> accounts_53;\n    // Variable to store the total money transacted\n    int total_money_transaction_53 = 0;\n    bool check_53 = false;\n\n    // Input loop to read transactions until '#' is encountered\n    while (true)\n    {\n        cin >> s_53;\n        if (s_53 == \"#\")\n        {\n            check_53 = true;\n        }\n        if (check_53)\n            break;\n        Transaction_53 t_53;\n        t_53.from_account_53 = s_53;\n        cin >> t_53.to_account_53 >> t_53.money_53 >> t_53.time_point_53 >> t_53.atm_53;\n        transactions_53.push_back(t_53);\n        from_accounts_53[t_53.from_account_53] += t_53.money_53;\n    }\n\n    check_53 = false;\n    // Query processing loop\n    while (true)\n    {\n        cin >> s_53;\n        if (s_53 == \"#\")\n            break;\n        if (s_53 != \"?total_money_transaction_from\" && check_53 == false)\n        {\n            check_53 = true;\n            // Processing transactions and building the adjacency list\n            for (auto t_53 : transactions_53)\n            {\n                total_money_transaction_53 += t_53.money_53;\n                accounts_53.insert(t_53.from_account_53);\n                accounts_53.insert(t_53.to_account_53);\n                adj_53[t_53.from_account_53].push_back(t_53.to_account_53); // Add this line\n            }\n        }\n\n        if (s_53 == \"?total_money_transaction_from\")\n        {\n            // Output the total money transferred from a specific account\n            string account_53;\n            cin >> account_53;\n            cout << from_accounts_53[account_53] << endl;\n        }\n        else if (s_53 == \"?list_sorted_accounts\")\n        {\n            // Output a sorted list of unique account names\n            for (const string &account_53 : accounts_53)\n            {\n                cout << account_53 << \" \";\n            }\n            cout << endl;\n        }\n        else if (s_53 == \"?total_money_transaction\")\n        {\n            // Output the total money transacted\n            cout << total_money_transaction_53 << endl;\n        }\n        else if (s_53 == \"?number_transactions\")\n        {\n            // Output the total number of transactions\n            cout << transactions_53.size() << endl;\n        }\n        else if (s_53 == \"?inspect_cycle\")\n        {\n            // Inspect if there is a cycle in the transaction graph\n            string account_53;\n            int k_53;\n            cin >> account_53 >> k_53;\n            visited_53.clear();\n            cout << (DFS_53(account_53, account_53, 1, k_53) ? 1 : 0) << endl;\n        }\n    }\n\n    return 0;\n}\n"
        },
        "Bai2": {
            "Problem": "Problem: Week 7 - Analyze sales order of an e-commerce company\n\nDescription\nData about sales in an e-commerce company (the e-commerce company has several shops) consists a sequence of lines, each line (represents an order) has the following information:\n            <CustomerID> <ProductID> <Price> <ShopID> <TimePoint>\nin which the customer <CustomerID> buys a product <ProductID> with price <Price> at the shop <ShopID> at the time-point <TimePoint>\n<CustomerID>: string of length from 3 to 10\n<ProductID>: string of length from 3 to 10\n<Price>: a positive integer from 1 to 1000\n<ShopID>: string of length from 3 to 10\n<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)\n\n\nPerform a sequence of queries of following types:\n?total_number_orders: return the total number of orders\n?total_revenue: return the total revenue the e-commerce company gets\n?revenue_of_shop <ShopID>: return the total revenue the shop <ShopID> gets \n?total_consume_of_customer_shop <CustomerID> <ShopID>: return the total revenue the shop <ShopID> sells products to customer <CustomerID> \n?total_revenue_in_period <from_time> <to_time>: return the total revenue the e-commerce gets of the period from <from_time> to <to_time> (inclusive)\n\nInput\nThe input consists of two blocks of data:\nThe first block is the operational data, which is a sequence of lines (number of lines can be upto 100000), each line contains the information of a submission with above format \nThe first block is terminated with a line containing the character #\nThe second block is the query block, which is a sequence of lines (number of lines can be upto 100000), each line is a query described above\nThe second block is terminated with a line containing the character #\n\nOutput\nWrite in each line, the result of the corresponding query \n\nExample\nInput\nC001 P001 10 SHOP001 10:30:10\nC001 P002 30 SHOP001 12:30:10\nC003 P001 40 SHOP002 10:15:20\nC001 P001 80 SHOP002 08:40:10\nC002 P001 130 SHOP001 10:30:10\nC002 P001 160 SHOP003 11:30:20\n#\n?total_number_orders\n?total_revenue\n?revenue_of_shop SHOP001\n?total_consume_of_customer_shop C001 SHOP001 \n?total_revenue_in_period 10:00:00 18:40:45\n#\n\n\nOutput \n6\n450\n170\n40\n370",
            "Code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct Transaction\n{\n    string customerId_53;\n    string productId_53;\n    string shopId_53;\n    string timePoint_53;\n    int price_53;\n} Order_53;\n\n// Function to compare orders based on time\nbool compareByTime_53(const Order_53 &a_53, const Order_53 &b_53)\n{\n    return !(a_53.timePoint_53 >= b_53.timePoint_53);\n}\n\nint main()\n{\n    // Disable synchronization between C and C++ streams for performance\n    ios::sync_with_stdio(false);\n    // Untie cin from cout for performance\n    cin.tie(0);\n\n    vector<Order_53> orders_53;\n    string input_53;\n    map<string, int> shopRevenues_53;\n    map<string, int> customerShopRevenues_53;\n    map<string, int> accumulatedRevenue_53;\n\n    // Input loop to read orders until '#' is encountered\n    while (true)\n    {\n        cin >> input_53;\n        if (input_53 == \"#\")\n        {\n            break;\n        }\n        Order_53 currentOrder_53;\n        currentOrder_53.customerId_53 = input_53;\n        cin >> currentOrder_53.productId_53 >> currentOrder_53.price_53 >> currentOrder_53.shopId_53 >> currentOrder_53.timePoint_53;\n        orders_53.push_back(currentOrder_53);\n    }\n\n    int totalRevenue_53 = 0;\n\n    bool checkTotalRevenue_53 = false;\n    bool checkRevenueOfShop_53 = false;\n    bool checkTotalConsumeOfCustomerShop_53 = false;\n    bool checkTotalRevenueInPeriod_53 = false;\n\n    // Query processing loop\n    while (true)\n    {\n        cin >> input_53;\n        if (input_53 == \"#\")\n            break;\n        else if (input_53 == \"?total_revenue\")\n        {\n            // Calculate and output total revenue\n            if (!checkTotalRevenue_53)\n            {\n                checkTotalRevenue_53 = true;\n                sort(orders_53.begin(), orders_53.end(), compareByTime_53);\n                for (auto &order_53 : orders_53)\n                {\n                    totalRevenue_53 += order_53.price_53;\n                    accumulatedRevenue_53[order_53.timePoint_53] = totalRevenue_53;\n                }\n                cout << totalRevenue_53 << endl;\n            }\n            else\n            {\n                cout << totalRevenue_53 << endl;\n            }\n        }\n        else if (input_53 == \"?total_number_orders\")\n        {\n            // Output the total number of orders\n            cout << orders_53.size() << endl;\n            continue;\n        }\n\n        if (input_53 == \"?revenue_of_shop\")\n        {\n            // Calculate and output revenue for a specific shop\n            if (!checkRevenueOfShop_53)\n            {\n                checkRevenueOfShop_53 = true;\n                for (auto &order_53 : orders_53)\n                {\n                    shopRevenues_53[order_53.shopId_53] += order_53.price_53;\n                }\n            }\n            string shopId_53;\n            cin >> shopId_53;\n            cout << shopRevenues_53[shopId_53] << endl;\n            continue;\n        }\n        if (input_53 == \"?total_revenue_in_period\")\n        {\n            // Calculate and output total revenue in a specified period\n            if (!checkTotalRevenueInPeriod_53)\n            {\n                checkTotalRevenueInPeriod_53 = true;\n                sort(orders_53.begin(), orders_53.end(), compareByTime_53);\n                for (auto &order_53 : orders_53)\n                {\n                    totalRevenue_53 += order_53.price_53;\n                    accumulatedRevenue_53[order_53.timePoint_53] = totalRevenue_53;\n                }\n            }\n            string fromTime_53, toTime_53;\n            cin >> fromTime_53 >> toTime_53;\n            auto fromIt_53 = accumulatedRevenue_53.lower_bound(fromTime_53);\n            auto toIt_53 = accumulatedRevenue_53.upper_bound(toTime_53);\n            int fromRevenue_53 = (fromIt_53 == accumulatedRevenue_53.begin()) ? 0 : prev(fromIt_53)->second;\n            int toRevenue_53 = (toIt_53 == accumulatedRevenue_53.begin()) ? 0 : prev(toIt_53)->second;\n            int revenue_53 = toRevenue_53 - fromRevenue_53;\n            cout << revenue_53 << endl;\n            continue;\n        }\n        if (input_53 == \"?total_consume_of_customer_shop\")\n        {\n            // Calculate and output total consumption for a specific customer-shop pair\n            if (!checkTotalConsumeOfCustomerShop_53)\n            {\n                checkTotalConsumeOfCustomerShop_53 = true;\n                for (auto &order_53 : orders_53)\n                {\n                    customerShopRevenues_53[order_53.customerId_53 + order_53.shopId_53] += order_53.price_53;\n                }\n            }\n            string customerId_53, shopId_53;\n            cin >> customerId_53 >> shopId_53;\n            cout << customerShopRevenues_53[customerId_53 + shopId_53] << endl;\n            continue;\n        }\n    }\n\n    return 0;\n}\n"
        }
    },
    "Tuần 8": {
        "Bài 1": {
            "Problem": "Problem: Week 8 - Analyze Code Submission of a Programming Contest\n\nDescription\nData about submission of a programming contest consists a sequence of lines, each line has the following information:\n                                                      <UserID> <ProblemID> <TimePoint> <Status> <Point>\nin which the user <UserID> submits his/her code to solve the problem <ProblemID> at time-point <TimePoint>, and gets status <Status> and point <Point>\n<UserID>: string of length from 3 to 10\n<ProblemID>: string under the format Pxy where x, y are digits 0,1,...,9 (for example P03, P10)\n<TimePoint>: string representing time-point with the format HH:MM:SS (for example, 09:45:20 means the time-point 9 hour 45 minutes 20 seconds)\n<Status>: string with two cases (ERR, OK)\n<Point>: integer from {0, 1, 2, ..., 10}\n\nA user can submit the code for solving each problem several time. The point that the user gets for a problem is the maximal point among the submissions for that problem.\n\nPerform a sequence of queries of following types:\n?total_number_submissions: return the number of submissions of the contest\n?number_error_submision: return the number of submissions having status ERR \n?number_error_submision_of_user <UserID>: return the number of submission having status ERR of user <UserID> \n?total_point_of_user <UserID>: return the total point of user <UserID> \n?number_submission_period <from_time_point> <to_time_point>: return the number of submissions in the period from <from_time_point> to <to_time_point> (inclusive)\n\nInput\nThe input consists of two blocks of data:\nThe first block is the operational data, which is a sequence of lines (number of lines can be up to 100000), each line contains the information of a submission with above format .The first block is terminated with a line containing the character #\nThe second block is the query block, which is a sequence of lines (number of lines can be up to 100000), each line is a query described above. The second block is terminated with a line containing the character #\n\nOutput\nWrite in each line, the result of the corresponding query \n\nExample\nInput\nU001 P01 10:30:20 ERR 0\nU001 P01 10:35:20 OK 10\nU001 P02 10:40:20 ERR 0\nU001 P02 10:55:20 OK 7\nU002 P01 10:40:20 ERR 0\nU001 P01 11:35:20 OK 8\nU002 P02 10:40:20 OK 10\n#\n?total_number_submissions\n?number_error_submision\n?number_error_submision_of_user U002 \n?total_point_of_user U001 \n?number_submission_period 10:00:00 11:30:45\n#\n\n\nOutput \n7\n3\n1\n17\n6\n",
            "Code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Constants for array sizes\nconst int MAX_USERS_53 = 10005;\nconst int MAX_PROBLEMS_53 = 105;\nconst int MAX_SUBMISSIONS_53 = 86405;\n\n// Function to convert a string to an integer\nint convertToInt_53(const string &s) {\n    int num = 0;\n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        }\n    }\n    return num;\n}\n\n// Function to convert time to seconds\nint convertTime_53(int time) {\n    return time / 10000 * 3600 + (time % 10000) / 100 * 60 + time % 100;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //Phan Trung Hieu - 20215373\n    // Variables for submission data\n    int numSubmissions_53 = 0, numErrors_53 = 0, point_53;\n    string userID_53, problemID_53, submissionTime_53, status_53, query_53, endTime_53;\n    \n    // Arrays to store user data\n    vector<vector<int>> userProblems_53(MAX_USERS_53, vector<int>(MAX_PROBLEMS_53, 0));\n    vector<int> userErrors_53(MAX_USERS_53, 0);\n    vector<int> userPoints_53(MAX_USERS_53, 0);\n    \n    // Arrays to store submission data\n    vector<int> submissionTimes_53(MAX_SUBMISSIONS_53, 0);\n    vector<int> wasSubmitted_53(MAX_SUBMISSIONS_53, 0);\n    vector<int> willSubmit_53(MAX_SUBMISSIONS_53, 0);\n\n    // Read the first user ID\n    cin >> userID_53;\n\n    // Process submissions until '#' is encountered\n    while (userID_53[0] != '#') {\n        ++numSubmissions_53;\n        cin >> problemID_53 >> submissionTime_53 >> status_53 >> point_53;\n        ++submissionTimes_53[convertTime_53(convertToInt_53(submissionTime_53))];\n\n        // Update user errors or problems based on submission status\n        if (status_53 == \"ERR\") {\n            ++userErrors_53[convertToInt_53(userID_53)];\n            ++numErrors_53;\n        } else {\n            int uID_53 = convertToInt_53(userID_53), pID_53 = convertToInt_53(problemID_53);\n            userProblems_53[uID_53][pID_53] = max(userProblems_53[uID_53][pID_53], point_53);\n        }\n\n        // Read the next user ID\n        cin >> userID_53;\n    }\n\n    // Calculate cumulative submission counts\n    for (int i = 1; i < MAX_SUBMISSIONS_53; ++i) {\n        wasSubmitted_53[i] = wasSubmitted_53[i - 1] + submissionTimes_53[i - 1];\n        willSubmit_53[i - 1] = numSubmissions_53 - wasSubmitted_53[i];\n    }\n\n    // Read the first query\n    cin >> query_53;\n\n    // Process queries until '#' is encountered\n    while (query_53[0] != '#') {\n        // Handle different types of queries\n        if (query_53[8] == 's') {\n            cin >> submissionTime_53 >> endTime_53;\n            // Output the number of submissions within the given time range\n            cout << numSubmissions_53 - wasSubmitted_53[convertTime_53(convertToInt_53(submissionTime_53))]\n                 - willSubmit_53[convertTime_53(convertToInt_53(endTime_53))] << endl;\n        } else if (query_53[1] == 'n') {\n            // Output the number of errors or total errors based on the query\n            if (query_53[23] != '\\0') {\n                cin >> userID_53;\n                cout << userErrors_53[convertToInt_53(userID_53)] << endl;\n            } else {\n                cout << numErrors_53 << endl;\n            }\n        } else if (query_53[7] == 'p') {\n            // Output the total points of a user\n            cin >> userID_53;\n            int uID_53 = convertToInt_53(userID_53);\n\n            if (!userPoints_53[uID_53]) {\n                for (int i = 0; i < MAX_PROBLEMS_53; i++) {\n                    userPoints_53[uID_53] += userProblems_53[uID_53][i];\n                }\n            }\n            cout << userPoints_53[uID_53] << endl;\n        } else if (query_53[7] == 'n') {\n            // Output the total number of submissions\n            cout << numSubmissions_53 << endl;\n        }\n\n        // Read the next query\n        cin >> query_53;\n    }\n\n    return 0;\n}\n"
        },
        "Bài 2": {
            "Problem": "Problem: Week 8 - Citizen Data Analysis\n\nDescription\nCITIZEN\nGiven a DataBase about citizen, perform queries over this DataBase.\nInput\nThe input consists of two blocks: the first block is the DataBase and the second block is the list of queries. Two blocks are separated by a line containing a character *.\n1. The first block (DataBase about citizen) consists of lines (number of lines can be upto 100000), each line is the information about a person and is under the format:\n                                   <code>  <dat_of_birth>  <fathher_code>   <mother_code>  <is_alive>  <region_code>\nin which:\n <code>: the code of the person which is a string of length 7\n <date_of_birth>: the date of birth of the person and has the format YYYY-MM-DD (for example 1980-02-23), <date_of_birth> is before 3000-12-31\n <fathher_code> and <mother_code> is the code of father and mother: they are also strings of length 7. If the code is 0000000, then the current person does not has information about his father or mother\n <is_alive>: a character with two values: \u2018Y\u2019 means that the person is still alive, and \u2018N\u2019 means tat the current person is died.\n <region_code>: the code of the region where the person lives\n\n2. The second block is the list of queries (number of queries can be upto 100000) over the DataBase which consists of following commands:\n NUMBER_PEOPLE: return the number of people (number of lines of the DataBase)\n NUMBER_PEOPLE_BORN_AT <date>: return the number of people having date-of-birth is equal to <date>\n MOST_ALIVE_ANCESTOR <code>: find the most ancestor (farthest in term of generation distance) of the given person <code>. Return the generation distance between the ancestor found and the given person\n NUMBER_PEOPLE_BORN_BETWEEN <from_date> <to_date>: compute the number of people having date-of-birth between <from_date> and <to_date> (<from_date> and <to_date> are under the form YYYY-MM-DD, <to_date> is before 3000-12-31)\n MAX_UNRELATED_PEOPLE: find a subset of people in which two any people of the subset do not have father/mother-children and the size of the subset is maximal. Return the size of the subset found.\nThe second block is terminated by a line containing ***.\nOutput\n Each line presents the result of the corresponding query (described above)\n\nExample\nInput\n0000001 1920-08-10 0000000 0000000 Y 00002\n0000002 1920-11-03 0000000 0000000 Y 00003\n0000003 1948-02-13 0000001 0000002 Y 00005\n0000004 1946-01-16 0000001 0000002 Y 00005\n0000005 1920-11-27 0000000 0000000 Y 00005\n0000006 1920-02-29 0000000 0000000 Y 00004\n0000007 1948-07-18 0000005 0000006 Y 00005\n0000008 1948-07-18 0000005 0000006 Y 00002\n0000009 1920-03-09 0000000 0000000 Y 00005\n0000010 1920-10-16 0000000 0000000 Y 00005\n*\nNUMBER_PEOPLE\nNUMBER_PEOPLE_BORN_AT 1919-12-10\nNUMBER_PEOPLE_BORN_AT 1948-07-18\nMAX_UNRELATED_PEOPLE\nMOST_ALIVE_ANCESTOR 0000008\nMOST_ALIVE_ANCESTOR 0000001\nNUMBER_PEOPLE_BORN_BETWEEN 1900-12-19 1928-11-16\nNUMBER_PEOPLE_BORN_BETWEEN 1944-08-13 1977-12-15\nNUMBER_PEOPLE_BORN_BETWEEN 1987-01-24 1988-06-03\n***\nOutput\n10\n0\n2\n6\n1\n0\n6\n4\n0",
            "Code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// Constants for array sizes\nconst int MAX_PERSONS_53 = 100001;\nconst int MAX_DATES_53 = 1200000;\n\n// Arrays to store data about persons and dates\nint born_53[MAX_DATES_53] = {}, was_born_53[MAX_DATES_53] = {}, will_born_53[MAX_DATES_53], ancestor_53[MAX_PERSONS_53][2];\nint parents_53[MAX_PERSONS_53][2], rela_53[21] = {}, x_53[22] = {}, n_53, kt_53 = 0, num_53 = 0;\n\n// Check if relationships are valid for the given set of persons\nbool check_53() {\n    for (int i = 1; i < n_53; ++i)\n        if (rela_53[parents_53[x_53[i]][0]] || rela_53[parents_53[x_53[i]][1]])\n            return false;\n    return true;\n}\n\n// Recursively try different combinations of persons for relationships\nvoid Try_53(int k) {\n    if (k == n_53) {\n        if (check_53())\n            kt_53 = 1;\n        return;\n    }\n    for (int i = x_53[k - 1] + 1; i <= num_53 - (n_53 - 1 - k); ++i) {\n        x_53[k] = i;\n        rela_53[i] = 1;\n        Try_53(k + 1);\n        rela_53[i] = 0;\n    }\n}\n\n// Convert a string to an integer, extracting only the numeric part\nint convertToInt_53(string s) {\n    int num = 0, j = s.length();\n    for (int i = 0; i < j; ++i)\n        if (s[i] < 58 && s[i] > 47) num = num * 10 + s[i] - 48;\n    return num;\n}\n\n// Convert a date to an index, treating it as a number in the form YYYYMMDD\nint convertDate_53(int date) {\n    return date / 10000 * 372 + (date % 10000) / 100 * 31 + date % 100;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    //Phan Trung Hieu - 20215373\n    string codee_53, date_53, father_53, mother_53, aliv_53, reg_53, query_53, date1_53;\n    cin >> codee_53;\n\n    // Process data about persons until the codee_53 is not '*'\n    while (codee_53[0] != '*') {\n        ++num_53;\n        cin >> date_53 >> father_53 >> mother_53 >> aliv_53 >> reg_53;\n        int code_53 = convertToInt_53(codee_53);\n        ++born_53[convertDate_53(convertToInt_53(date_53))];\n        parents_53[code_53][0] = convertToInt_53(father_53);\n        parents_53[code_53][1] = convertToInt_53(mother_53);\n        cin >> codee_53;\n    }\n\n    // Precompute arrays related to birth dates\n    for (int i = 1; i < MAX_DATES_53; ++i) {\n        was_born_53[i] = was_born_53[i - 1] + born_53[i - 1];\n        will_born_53[i - 1] = num_53 - was_born_53[i];\n    }\n\n    cin >> query_53;\n\n    // Process queries until the query_53 is not '*'\n    while (query_53[0] != '*') {\n        if (query_53[1] == 'U') {\n            if (query_53[13] == '\\0') {\n                cout << num_53 << endl;\n            } else if (query_53[19] == 'A') {\n                cin >> date_53;\n                cout << born_53[convertDate_53(convertToInt_53(date_53))] << endl;\n            } else {\n                cin >> date_53 >> date1_53;\n                cout << num_53 - was_born_53[convertDate_53(convertToInt_53(date_53))] - will_born_53[convertDate_53(convertToInt_53(date1_53))] << endl;\n            }\n        } else if (query_53[1] == 'O') {\n            cin >> codee_53;\n            int p_53 = -1, k_53 = 0;\n            ancestor_53[0][0] = convertToInt_53(codee_53);\n\n            // Compute ancestor relationships using a BFS approach\n            while (++p_53 <= k_53) {\n                for (int i = 0; i < 2; ++i) {\n                    if (parents_53[ancestor_53[p_53][0]][i]) {\n                        ancestor_53[++k_53][0] = parents_53[ancestor_53[p_53][0]][i];\n                        ancestor_53[k_53][1] = ancestor_53[p_53][1] + 1;\n                    }\n                }\n            }\n            cout << ancestor_53[k_53][1] << endl;\n        } else if (query_53[1] == 'A') {\n            n_53 = num_53 + 1;\n\n            // Try different combinations of persons for relationships\n            for (n_53; n_53 >= 0; --n_53) {\n                Try_53(1);\n                if (kt_53)\n                    break;\n            }\n            cout << n_53 - 1 << endl;\n        }\n\n        cin >> query_53;\n    }\n\n    return 0;\n}\n"
        }
    }
}